<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Buckeye Hunter Hub â€” Mobile Hunting Map</title>
  
  <!-- Leaflet core -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  
  <!-- Leaflet.draw -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css"/>
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>

  <!-- SunCalc for sunrise/sunset -->
  <script src="https://unpkg.com/suncalc@1.9.0/suncalc.js"></script>

  <style>
    :root{
      --bg:#0b1a0f;        /* deep forest */
      --panel:#101f14;     /* card */
      --muted:#1a2b1f;
      --accent:#6dbc5d;    /* green */
      --text:#e7f1e8;
      --subtle:#a3b7a6;
      --danger:#f87171;
      --shadow:0 12px 30px rgba(0,0,0,.35);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
    }
    html,body,#app{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui,Roboto,Arial,sans-serif}
    #map{position:fixed;inset:0}
    #map.placing{cursor: crosshair}

    /* Info panel (smaller + draggable) */
    .panel{position:fixed;left:12px;top:80px;z-index:1000;background:var(--panel);border:1px solid #203325;border-radius:12px;box-shadow:var(--shadow);padding:8px 10px;min-width:180px;max-width:240px}
    .panel h3{margin:0 0 6px;font-size:14px;display:flex;align-items:center;gap:8px;cursor:move}
    .row{display:flex;align-items:center;justify-content:space-between;gap:8px;padding:4px 0;border-bottom:1px solid #1d3323}
    .row:last-child{border-bottom:0}
    .tag{font-size:11px;color:var(--subtle)}

    /* Bottom main menu */
    .main-menu{position:fixed;left:0;right:0;bottom:0;z-index:1200;display:flex;gap:8px;justify-content:space-around;align-items:center;padding:10px 12px calc(10px + var(--safe-bottom));background:linear-gradient(180deg,rgba(11,26,15,.1),rgba(11,26,15,.85));backdrop-filter:blur(8px);border-top:1px solid #203325;flex-wrap:wrap}
    .main-menu button{flex:1;max-width:140px;padding:10px;border:1px solid #25432b;border-radius:12px;background:#14271a;color:var(--text);font-size:14px;cursor:pointer;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .wind-btn{display:flex;align-items:center;gap:8px;max-width:220px}
    #windText{font-size:12px}
    .wind-arrow{width:0;height:0;border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:12px solid #e7f1e8;display:inline-block;transform:rotate(0deg)}

    /* Sheets (backdrop + panel) */
    .backdrop{position:fixed;inset:0;background:rgba(0,0,0,.35);z-index:1199;display:none}
    .backdrop.show{display:block}
    .sheet{position:fixed;left:0;right:0;bottom:0;z-index:1200;background:var(--panel);border-top:1px solid #203325;border-radius:16px 16px 0 0;box-shadow:var(--shadow);transform:translateY(110%);transition:transform .25s ease}
    .sheet.show{transform:translateY(0)}
    .sheet .grab{width:36px;height:4px;border-radius:999px;background:#2b4231;margin:8px auto}
    .sheet .option{display:flex;align-items:center;justify-content:space-between;padding:12px 16px;border-top:1px solid #1d3323;cursor:pointer}
    .sheet h4{margin:6px 16px 8px;font-size:14px;color:var(--subtle)}
    .sheet .content{padding:4px 16px 14px}
    .sheet .row{border:0}
    .sheet input[type="text"], .sheet input[type="number"], .sheet input[type="search"], .sheet select{width:100%;padding:8px 10px;border-radius:10px;border:1px solid #25432b;background:#14271a;color:var(--text)}
    .btn{padding:8px 12px;border:1px solid #25432b;border-radius:10px;background:#14271a;color:var(--text);cursor:pointer}
    .btn.danger{border-color:#5a2222;background:#331616}

    /* Waypoints list */
    .wp-list{max-height:38vh;overflow:auto;margin-top:6px}
    .item{display:grid;grid-template-columns:auto 1fr auto auto;gap:10px;align-items:center;padding:8px 0;border-bottom:1px solid #1d3323}
    .emoji{font-size:18px}
    .name{min-width:0}
    .actions button{margin-left:8px}

    /* Segment distance labels */
    .seglabel{background:rgba(16,31,20,.92);border:1px solid #203325;border-radius:10px;padding:2px 6px;font-size:11px;color:var(--text);box-shadow:var(--shadow)}

    @media (max-width:640px){
      .panel{left:8px;top:76px}
      .main-menu{gap:6px}
      .main-menu button{font-size:13px;padding:8px;max-width:120px}
      .wind-btn{max-width:200px}
      #windText{font-size:11px}
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="map"></div>

    <!-- Field Info panel (hidden by default; draggable) -->
    <section class="panel" id="infoPanel" style="display:none;">
      <h3 id="infoHandle">ðŸ“‹ Field Info</h3>
      <div class="row"><span>Sunrise</span><strong id="pSunrise" class="tag">--:--</strong></div>
      <div class="row"><span>Sunset</span><strong id="pSunset" class="tag">--:--</strong></div>
      <div class="row"><span>Day Length</span><strong id="pDay" class="tag">--h --m</strong></div>
      <div class="row"><span>Track Distance</span><strong id="pTrkDist" class="tag">0 m</strong></div>
      <div class="row"><span>Track Duration</span><strong id="pTrkDur" class="tag">0:00</strong></div>
      <p class="tag">Tip: start the Track Recorder to populate distance & duration.</p>
    </section>

    <!-- Bottom main menu -->
    <nav class="main-menu" id="mainMenu">
      <button id="toggleFieldInfo">Field Info</button>
      <button id="menuWind" class="wind-btn"><span class="wind-arrow" id="windArrow"></span><span id="windText">Wind: --</span></button>
      <button id="menuWaypoints">Waypoints</button>
      <button id="menuTrack">Track</button>
      <button id="menuRadar">Radar</button>
      <button id="toggleBasemap">Basemap</button>
      <button id="btnExport">Export</button>
      <button id="btnImport">Import</button>
      <button id="btnDeleteMode">Delete: Off</button>
      <button id="menuLocate">Locate Me</button>
      <input type="file" id="fileImport" accept=".json,.geojson,application/json,application/geo+json" style="display:none" />
    </nav>

    <!-- Shared backdrop for sheets -->
    <div class="backdrop" id="sheetBackdrop"></div>

    <!-- Basemap & Overlays sheet -->
    <div class="sheet" id="basemapSheet" aria-hidden="true">
      <div class="grab"></div>
      <h4>Basemap</h4>
      <div class="option" data-radio="basemap" data-value="basic"><span>Basic</span><input type="radio" name="basemap" value="basic"></div>
      <div class="option" data-radio="basemap" data-value="satellite"><span>Satellite</span><input type="radio" name="basemap" value="satellite"></div>
      <div class="option" data-radio="basemap" data-value="topo"><span>Topographic</span><input type="radio" name="basemap" value="topo"></div>
      <h4 style="margin-top:10px">Overlays</h4>
      <div class="option"><span>Ohio Public Hunting</span><input id="ovlOhio" type="checkbox"></div>
      <div class="option"><span>My Drawings</span><input id="ovlDraw" type="checkbox"></div>
      <div class="option"><span>Hunt Markers</span><input id="ovlMarks" type="checkbox"></div>
      <div class="option"><span>My Track</span><input id="ovlTrack" type="checkbox"></div>
    </div>

    <!-- Waypoints + Shapes manager sheet -->
    <div class="sheet" id="waypointsSheet" aria-hidden="true">
      <div class="grab"></div>
      <h4>Waypoints & Shapes</h4>
      <div class="content">
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-bottom:8px">
          <select id="wpType">
            <option value="stand">Tree Stand</option>
            <option value="feeder">Feeder</option>
            <option value="camera">Trail Camera</option>
            <option value="scrape">Scrape</option>
            <option value="rub">Rub</option>
            <option value="water">Water Source</option>
          </select>
          <input id="wpName" type="text" placeholder="Name (optional)" />
        </div>
        <div style="display:flex; gap:8px; margin-bottom:10px">
          <button class="btn" id="wpAddCenter">Add at Map Center</button>
          <button class="btn" id="wpAddGPS">Add from GPS</button>
        </div>
        <input id="wpSearch" type="search" placeholder="Search by name or type" />
        <div class="wp-list" id="wpList"></div>
      </div>
    </div>

    <!-- Track recorder sheet -->
    <div class="sheet" id="trackSheet" aria-hidden="true">
      <div class="grab"></div>
      <h4>Track Recorder</h4>
      <div class="content">
        <div class="row"><span>Status</span><strong id="trkStatus" class="tag">Stopped</strong></div>
        <div class="row"><span>Points</span><strong id="trkPts" class="tag">0</strong></div>
        <div class="row"><span>Distance</span><strong id="trkDist" class="tag">0 m</strong></div>
        <div class="row"><span>Duration</span><strong id="trkDur" class="tag">0:00</strong></div>
        <label style="display:flex;align-items:center;gap:8px;margin-top:8px"><input type="checkbox" id="trkFollow"/> Auto-center while recording</label>
        <div style="display:flex;gap:8px;margin-top:10px">
          <button class="btn" id="trkStartStop">Start</button>
          <button class="btn danger" id="trkClear">Clear Track</button>
          <button class="btn" id="trkExport">Export GPX</button>
        </div>
      </div>
    </div>

    <!-- Radar sheet -->
    <div class="sheet" id="radarSheet" aria-hidden="true">
      <div class="grab"></div>
      <h4>Weather Radar</h4>
      <div class="content">
        <div class="option"><span>Visible</span><input id="radarToggle" type="checkbox"></div>
        <div class="option"><span>Source</span>
          <div>
            <label style="margin-right:10px"><input type="radio" name="radarSrc" value="rainviewer"> RainViewer</label>
            <label><input type="radio" name="radarSrc" value="noaa"> NOAA</label>
          </div>
        </div>
        <div class="option"><span>Opacity</span><input id="radarOpacity" type="range" min="0" max="1" step="0.05" value="0.6" style="width:160px"></div>
        <p class="tag">Tip: Tap the Radar button to toggle visibility quickly; use this sheet to change source & opacity.</p>
      </div>
    </div>
  </div>

  <script>
    /*******************
     * MAP & BASELAYERS *
     *******************/
    const map = L.map('map').setView([40.4173, -82.9071], 7);
    const basic = L.tileLayer('https://api.maptiler.com/maps/basic/{z}/{x}/{y}.png?key=YOUR_MAPTILER_KEY', { attribution: '&copy; MapTiler & OpenStreetMap contributors' }).addTo(map);
    const satellite = L.tileLayer('https://api.maptiler.com/tiles/satellite-v2/{z}/{x}/{y}.jpg?key=YOUR_MAPTILER_KEY', { attribution: '&copy; MapTiler' });
    const topo = L.tileLayer('https://api.maptiler.com/maps/topo/{z}/{x}/{y}.png?key=YOUR_MAPTILER_KEY', { attribution: '&copy; MapTiler & OpenStreetMap contributors' });

    const baseByKey = { basic, satellite, topo };
    const STORAGE_BASE = 'ui_basemap_key';
    function setBasemap(key){ Object.values(baseByKey).forEach(l=> map.removeLayer(l)); baseByKey[key].addTo(map); localStorage.setItem(STORAGE_BASE, key); }
    (function restoreBasemap(){ const k = localStorage.getItem(STORAGE_BASE); if(k && baseByKey[k]) setBasemap(k); })();

    /*******************
     * DRAWING LAYERS  *
     *******************/
    const drawnItems = new L.FeatureGroup().addTo(map);
    const drawControl = new L.Control.Draw({ position:'topleft', edit:{ featureGroup: drawnItems }, draw:{ circle:true } });
    map.addControl(drawControl);

    const STORAGE_DRAW = 'bhh_drawings_v4';

    function featureTypeFromLayer(l){
      if(l instanceof L.Circle) return 'circle';
      if(l instanceof L.Rectangle) return 'rectangle';
      if(l instanceof L.Polygon && !(l instanceof L.Rectangle)) return 'polygon';
      if(l instanceof L.Polyline && !(l instanceof L.Polygon)) return 'polyline';
      return 'shape';
    }

    function defaultShapeName(type){
      const base = {polyline:'Line', polygon:'Area', rectangle:'Plot', circle:'Circle', shape:'Shape'}[type] || 'Shape';
      let n=1; drawnItems.eachLayer(l=>{ if(featureTypeFromLayer(l)===type) n++; });
      return `${base} ${n}`;
    }

    function saveDraw(){
      const geojson = { type:'FeatureCollection', features:[] };
      const circles = [];
      drawnItems.eachLayer(l=>{
        const type = featureTypeFromLayer(l);
        if(type==='circle'){
          const c = l.getLatLng();
          circles.push({ lat:c.lat, lng:c.lng, radius:l.getRadius(), properties:{ name:l._bhhName || defaultShapeName('circle'), shapeType:'circle' } });
        } else {
          const f = l.toGeoJSON();
          f.properties = Object.assign({}, f.properties||{}, { name: l._bhhName || defaultShapeName(type), shapeType:type });
          geojson.features.push(f);
        }
      });
      const bundle = { geojson, circles };
      localStorage.setItem(STORAGE_DRAW, JSON.stringify(bundle));
    }

    function restoreDraw(){
      const raw = localStorage.getItem(STORAGE_DRAW);
      if(!raw){ return; }
      try{
        const data = JSON.parse(raw);
        if(data && data.geojson){
          L.geoJSON(data.geojson, { onEachFeature:(feat,layer)=>{
            layer._bhhName = (feat.properties && feat.properties.name) || defaultShapeName(featureTypeFromLayer(layer));
            drawnItems.addLayer(layer);
            if(layer instanceof L.Polyline && !(layer instanceof L.Polygon)) labelPolylineSegments(layer);
          }});
          (data.circles||[]).forEach(c=>{
            const layer = L.circle([c.lat,c.lng], { radius:c.radius });
            layer._bhhName = (c.properties && c.properties.name) || defaultShapeName('circle');
            drawnItems.addLayer(layer);
          });
        } else if(data.type==='FeatureCollection'){ // legacy
          L.geoJSON(data, { onEachFeature:(_,layer)=>{ layer._bhhName = defaultShapeName(featureTypeFromLayer(layer)); drawnItems.addLayer(layer); if(layer instanceof L.Polyline && !(layer instanceof L.Polygon)) labelPolylineSegments(layer); } });
        }
      }catch(e){ console.warn('restore drawings failed', e); }
    }

    restoreDraw();

    map.on(L.Draw.Event.CREATED, e=>{
      const layer = e.layer;
      const type = e.layerType || featureTypeFromLayer(layer);
      layer._bhhName = defaultShapeName(type);
      drawnItems.addLayer(layer);
      if(type==='polyline') labelPolylineSegments(layer);
      saveDraw();
      refreshWaypointsUI();
    });
    map.on(L.Draw.Event.EDITED, e=>{ e.layers.eachLayer(l=>{ if(l instanceof L.Polyline && !(l instanceof L.Polygon)) { relabelPolyline(l); } }); saveDraw(); refreshWaypointsUI(); });
    map.on(L.Draw.Event.DELETED, e=>{ e.layers.eachLayer(l=> removeSegLabels(l)); saveDraw(); refreshWaypointsUI(); });

    /*******************
     * SEGMENT LABELS FOR POLYLINES
     *******************/
    const segmentLabelsGroup = L.layerGroup().addTo(map);

    function fmtFeetMiles(m){
      const ft = m * 3.28084;
      if(m >= 1609.344) return (m/1609.344).toFixed(2) + ' mi';
      return Math.round(ft) + ' ft';
    }

    function removeSegLabels(layer){
      if(layer._segLabels){ layer._segLabels.forEach(lbl=> segmentLabelsGroup.removeLayer(lbl)); layer._segLabels = null; }
    }

    function labelPolylineSegments(layer){
      removeSegLabels(layer);
      const latlngs = layer.getLatLngs();
      const pts = Array.isArray(latlngs[0]) ? latlngs[0] : latlngs; // simple polyline
      const labels=[];
      for(let i=1;i<pts.length;i++){
        const a = pts[i-1], b = pts[i];
        const d = map.distance(a, b);
        const mid = L.latLng((a.lat+b.lat)/2, (a.lng+b.lng)/2);
        const marker = L.marker(mid, { interactive:false, icon: L.divIcon({ className:'', html:`<div class="seglabel">${fmtFeetMiles(d)}</div>` }) });
        marker.addTo(segmentLabelsGroup);
        labels.push(marker);
      }
      layer._segLabels = labels;
    }

    function relabelPolyline(layer){ labelPolylineSegments(layer); }

    /*******************
     * MARKERS (WAYPOINTS)
     *******************/
    const markersLayer = L.featureGroup().addTo(map);
    const STORAGE_MARK = 'bhh_markers_v3';
    const IS_MOBILE = matchMedia('(max-width:640px)').matches;
    const ICON_SZ = IS_MOBILE ? 28 : 32;
    const FONT_SZ = IS_MOBILE ? 16 : 18;

    function makeIcon(bg,emoji){
      return L.divIcon({
        className:'',
        html:`<div style="background:${bg};border:2px solid #333;border-radius:50%;width:${ICON_SZ}px;height:${ICON_SZ}px;display:flex;align-items:center;justify-content:center;font-size:${FONT_SZ}px;color:#fff;box-shadow:0 2px 6px rgba(0,0,0,.4);">${emoji}</div>`,
        iconSize:[ICON_SZ,ICON_SZ], iconAnchor:[ICON_SZ/2, ICON_SZ], popupAnchor:[0, -ICON_SZ*0.9]
      });
    }

    const markerTypes = {
      stand:{label:'Tree Stand', emoji:'ðŸŽ¯', icon:makeIcon('#2563eb','ðŸŽ¯')},
      feeder:{label:'Feeder', emoji:'ðŸ½ï¸', icon:makeIcon('#16a34a','ðŸ½ï¸')},
      camera:{label:'Trail Camera', emoji:'ðŸ“·', icon:makeIcon('#111827','ðŸ“·')},
      scrape:{label:'Scrape', emoji:'ðŸ¦Œ', icon:makeIcon('#6d28d9','ðŸ¦Œ')},
      rub:{label:'Rub', emoji:'ðŸªµ', icon:makeIcon('#b45309','ðŸªµ')},
      water:{label:'Water Source', emoji:'ðŸ’§', icon:makeIcon('#0891b2','ðŸ’§')}
    };

    let activeType=null; let deleteMode=false;
    function setActiveType(type){ activeType=type; document.getElementById('map').classList.toggle('placing', !!type); }

    function uid(){ return Date.now().toString(36)+Math.random().toString(36).slice(2,7); }
    function defaultName(type){ const base = markerTypes[type]?.label || 'Marker'; let n = 1; markersLayer.eachLayer(m=>{ if(m.options.type===type) n++; }); return `${base} ${n}`; }

    function addMarker(latlng, type, name, id){
      const cfg = markerTypes[type] || {label:'Marker', emoji:'ðŸ“', icon:makeIcon('#555','ðŸ“')};
      const markerId = id || uid();
      const markerName = name || defaultName(type);
      const m = L.marker(latlng, { icon: cfg.icon, draggable:true, type, id: markerId, name: markerName });
      const setPopup = () => m.bindPopup(`<b>${m.options.name}</b><div class=\"tag\">${cfg.label}</div><br><button class=\"del\">Delete</button>`, {autoPan:false});
      setPopup();
      m.on('dragend', saveMarkers);
      m.on('click', () => { if(deleteMode){ markersLayer.removeLayer(m); saveMarkers(); refreshWaypointsUI(); } });
      m.on('popupopen', (e)=>{ const btn = e.popup.getElement().querySelector('button.del'); if(btn) btn.addEventListener('click', ()=> { markersLayer.removeLayer(m); saveMarkers(); refreshWaypointsUI(); }); });
      markersLayer.addLayer(m);
      saveMarkers();
      return m;
    }

    function serializeMarkers(){ const list=[]; markersLayer.eachLayer(m=>{ const {lat,lng}=m.getLatLng(); list.push({id:m.options.id, name:m.options.name, type:m.options.type||'marker', lat, lng}); }); return list; }
    function deserializeMarkers(list){ markersLayer.clearLayers(); (list||[]).forEach(m=> addMarker([m.lat,m.lng], m.type, m.name, m.id)); }
    function saveMarkers(){ localStorage.setItem(STORAGE_MARK, JSON.stringify(serializeMarkers())); }
    ;(function restoreMarkers(){ try{ const raw=localStorage.getItem(STORAGE_MARK); if(raw) deserializeMarkers(JSON.parse(raw)); }catch(e){} })();

    map.on('click', e=>{ if(!activeType) return; addMarker(e.latlng, activeType); setActiveType(null); refreshWaypointsUI(); });

    /*******************
     * WAYPOINTS & SHAPES LIST UI
     *******************/
    const wpList = document.getElementById('wpList');
    const wpSearch = document.getElementById('wpSearch');
    const wpType = document.getElementById('wpType');
    const wpName = document.getElementById('wpName');

    document.getElementById('wpAddCenter').onclick = ()=>{ const t=wpType.value; const n=wpName.value||undefined; addMarker(map.getCenter(), t, n); refreshWaypointsUI(); wpName.value=''; };
    document.getElementById('wpAddGPS').onclick = ()=>{ if(!navigator.geolocation){ alert('Geolocation not supported'); return; } navigator.geolocation.getCurrentPosition(pos=>{ const t=wpType.value; const n=wpName.value||undefined; addMarker([pos.coords.latitude, pos.coords.longitude], t, n); refreshWaypointsUI(); wpName.value=''; }, err=> alert('Location error: '+err.message), {enableHighAccuracy:true, timeout:8000}); };

    function gatherShapes(){
      const arr=[];
      drawnItems.eachLayer(l=>{
        const type = featureTypeFromLayer(l);
        let center = l.getBounds ? l.getBounds().getCenter() : (l.getLatLng ? l.getLatLng() : map.getCenter());
        arr.push({ kind:'shape', type, name: l._bhhName || defaultShapeName(type), layer:l, center });
      });
      return arr;
    }

    function getWaypoints(){
      const pts=[];
      markersLayer.eachLayer(m=>{ const {lat,lng}=m.getLatLng(); pts.push({ kind:'wp', id:m.options.id, name:m.options.name, type:m.options.type, lat, lng, layer:m }); });
      return pts;
    }

    function emojiFor(item){
      if(item.kind==='shape'){
        return ({polyline:'ðŸ“', polygon:'â¬ ', rectangle:'â–­', circle:'â—¯'})[item.type] || 'â¬£';
      }
      return markerTypes[item.type]?.emoji || 'ðŸ“';
    }

    function labelFor(item){
      if(item.kind==='shape'){
        return ({polyline:'Line', polygon:'Area', rectangle:'Plot', circle:'Circle'})[item.type] || 'Shape';
      }
      return markerTypes[item.type]?.label || 'Marker';
    }

    function allItems(){ return [...getWaypoints(), ...gatherShapes()]; }

    function refreshWaypointsUI(){
      const q = (wpSearch.value||'').toLowerCase();
      const items = allItems().filter(w=> !q || (w.name && w.name.toLowerCase().includes(q)) || (labelFor(w).toLowerCase().includes(q)));
      wpList.innerHTML = items.map((w,i)=>`
        <div class="item" data-kind="${w.kind}" data-idx="${i}">
          <div class="emoji">${emojiFor(w)}</div>
          <div class="name"><input type="text" value="${(w.name||'').replace(/&/g,'&amp;').replace(/"/g,'&quot;')}"/></div>
          <div class="actions"><button class="btn fly">Fly</button></div>
          <div class="actions"><button class="btn danger del">Delete</button></div>
        </div>`).join('') || '<p class="tag" style="margin-top:8px">No items yet.</p>';
    }

    wpList.addEventListener('click', (e)=>{
      const item = e.target.closest('.item'); if(!item) return;
      const idx = parseInt(item.dataset.idx,10);
      const items = allItems(); const obj = items[idx]; if(!obj) return;
      if(e.target.classList.contains('fly')){
        if(obj.kind==='wp'){ map.setView([obj.lat, obj.lng], Math.max(map.getZoom(), 16)); obj.layer.openPopup(); }
        else { if(obj.layer.getBounds){ map.fitBounds(obj.layer.getBounds(), { maxZoom: 18 }); } else if(obj.center){ map.setView(obj.center, 17); } }
      }
      if(e.target.classList.contains('del')){
        if(obj.kind==='wp'){ markersLayer.removeLayer(obj.layer); saveMarkers(); }
        else { removeSegLabels(obj.layer); drawnItems.removeLayer(obj.layer); saveDraw(); }
        refreshWaypointsUI();
      }
    });

    wpList.addEventListener('input', (e)=>{
      const item = e.target.closest('.item'); if(!item) return; const idx = parseInt(item.dataset.idx,10); const items = allItems(); const obj = items[idx]; if(!obj) return;
      if(e.target.type==='text'){
        const val = e.target.value;
        if(obj.kind==='wp'){ obj.layer.options.name = val; const cfg = markerTypes[obj.layer.options.type] || {label:'Marker'}; obj.layer.bindPopup(`<b>${obj.layer.options.name}</b><div class=\"tag\">${cfg.label}</div><br><button class=\"del\">Delete</button>`); saveMarkers(); }
        else { obj.layer._bhhName = val; saveDraw(); }
      }
    });

    /*******************
     * TRACK RECORDER   *
     *******************/
    const trackLayer = L.polyline([], { color:'#22d3ee', weight:4, opacity:0.9 }).addTo(map);
    const STORAGE_TRK = 'bhh_track_v1';
    let trackPoints = []; // {lat,lng,t}
    let watchId = null; let startTime = null; let lastPoint = null;

    function loadTrack(){ try{ const raw=localStorage.getItem(STORAGE_TRK); if(raw){ trackPoints = JSON.parse(raw)||[]; trackLayer.setLatLngs(trackPoints.map(p=> [p.lat,p.lng])); } }catch{}; updateTrackStats(); }
    function saveTrack(){ localStorage.setItem(STORAGE_TRK, JSON.stringify(trackPoints)); updateTrackStats(); }

    function appendPoint(lat,lng,t){ const pt = {lat,lng,t: t||Date.now()}; if(lastPoint){ const d = map.distance([lastPoint.lat,lastPoint.lng],[lat,lng]); if(d < 3) return; } trackPoints.push(pt); lastPoint = pt; trackLayer.addLatLng([lat,lng]); saveTrack(); }

    function trackDistance(){ let d=0; for(let i=1;i<trackPoints.length;i++){ d += map.distance([trackPoints[i-1].lat,trackPoints[i-1].lng],[trackPoints[i].lat,trackPoints[i].lng]); } return d; }
    function updateTrackStats(){ const pts = trackPoints.length; const dist = trackDistance(); document.getElementById('trkPts').textContent = pts; const distText = dist>1609.344 ? (dist/1609.344).toFixed(2)+' mi' : Math.round(dist*3.28084)+' ft'; document.getElementById('trkDist').textContent = distText; const durMs = startTime ? (Date.now()-startTime) : (trackPoints.length? (trackPoints[trackPoints.length-1].t - trackPoints[0].t):0); const mm = Math.floor(durMs/60000), ss=(Math.floor(durMs/1000)%60).toString().padStart(2,'0'); document.getElementById('trkDur').textContent = `${mm}:${ss}`; document.getElementById('pTrkDist').textContent = distText; document.getElementById('pTrkDur').textContent = `${mm}:${ss}`; }

    function startTrack(){ if(!navigator.geolocation){ alert('Geolocation not supported'); return; } if(watchId) return; document.getElementById('trkStatus').textContent = 'Recording'; document.getElementById('trkStartStop').textContent = 'Stop'; startTime = Date.now(); watchId = navigator.geolocation.watchPosition(pos=>{ const {latitude, longitude} = pos.coords; appendPoint(latitude, longitude, Date.now()); if(document.getElementById('trkFollow').checked){ map.setView([latitude, longitude], Math.max(map.getZoom(), 16)); } }, err=>{ console.warn('track error', err); }, { enableHighAccuracy:true, maximumAge:5000 }); }
    function stopTrack(){ if(!watchId) return; navigator.geolocation.clearWatch(watchId); watchId=null; document.getElementById('trkStatus').textContent = 'Stopped'; document.getElementById('trkStartStop').textContent = 'Start'; updateTrackStats(); }
    function clearTrack(){ stopTrack(); trackPoints=[]; lastPoint=null; trackLayer.setLatLngs([]); saveTrack(); }

    function exportGPX(){ if(!trackPoints.length){ alert('No track to export'); return; } const name = 'BHH Track ' + new Date(trackPoints[0].t).toISOString().slice(0,10); const head = `<?xml version="1.0" encoding="UTF-8"?>\n<gpx version="1.1" creator="BuckeyeHunterHub" xmlns="http://www.topografix.com/GPX/1/1">\n<trk><name>${name}</name><trkseg>`; const seg = trackPoints.map(p=>`<trkpt lat="${p.lat}" lon="${p.lng}"><time>${new Date(p.t).toISOString()}</time></trkpt>`).join(''); const tail = `</trkseg></trk></gpx>`; const blob = new Blob([head+seg+tail], {type:'application/gpx+xml'}); const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=name.replace(/\s+/g,'_')+'.gpx'; a.click(); URL.revokeObjectURL(url); }

    loadTrack();

    /*******************
     * WIND (live by location with map-center fallback) *
     *******************/
    const btnWind = document.getElementById('menuWind');
    const windText = document.getElementById('windText');
    const windArrow = document.getElementById('windArrow');

    function degToCardinal(d){ const dirs = ['N','NE','E','SE','S','SW','W','NW']; return dirs[Math.round(d/45)%8]; }
    function updateWindUI(fromDeg, speed){ const toDeg = (fromDeg + 180) % 360; const from = degToCardinal(fromDeg); const to = degToCardinal(toDeg); windArrow.style.transform = `rotate(${toDeg}deg)`; windText.textContent = `Wind: ${from} â†’ ${to}  ${Math.round(speed)} mph`; }

    async function fetchWindAt(lat, lng){ const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&current=wind_speed_10m,wind_direction_10m&wind_speed_unit=mph`; const r = await fetch(url); if(!r.ok) throw new Error('wind fetch failed'); const j = await r.json(); const cur = j.current || j.current_weather || {}; const speed = cur.wind_speed_10m ?? cur.windspeed ?? 0; const dir = cur.wind_direction_10m ?? cur.winddirection ?? 0; updateWindUI(dir, speed); }

    async function refreshWind(){ try{ await new Promise((res,rej)=>{ if(!navigator.geolocation) return rej('no geo'); navigator.geolocation.getCurrentPosition(p=>res(p), e=>rej(e), {enableHighAccuracy:true, timeout:6000}); }); } catch(_) { const c = map.getCenter(); try{ await fetchWindAt(c.lat, c.lng); return; } catch(e){ windText.textContent='Wind: n/a'; return; } } navigator.geolocation.getCurrentPosition(async pos=>{ try{ await fetchWindAt(pos.coords.latitude, pos.coords.longitude); } catch(e){ const c=map.getCenter(); try{ await fetchWindAt(c.lat,c.lng);}catch{ windText.textContent='Wind: n/a'; } } }); }

    btnWind.onclick = refreshWind; refreshWind(); map.on('moveend', ()=>{ if(windText.textContent.includes('n/a')) refreshWind(); }); setInterval(refreshWind, 15*60*1000);

    /*******************
     * OHIO PUBLIC HUNTING (Local file first, then ODNR)
     *******************/
    const ohioPublic = L.geoJSON(null, {
      style:{ color:'#8b5cf6', weight:2, fillOpacity:0.15 },
      onEachFeature:(feat, layer)=>{
        const p = feat && feat.properties ? feat.properties : {};
        const preferred = ['NAME','AREA_NAME','UNIT_NAME','PARK_NAME','SITE_NAME','COUNTY','ACRES','AREA_ACRES','OWNER','AGENCY','STATUS','TYPE','ACCESS','SEASON'];
        const headerKey = preferred.find(k=> k in p) || Object.keys(p)[0];
        const name = headerKey ? String(p[headerKey]) : 'Public Hunting Area';
        const keysOrdered = [...new Set([...preferred.filter(k=>k in p), ...Object.keys(p)])].slice(0,12);
        const rows = keysOrdered.map(k=>`<div><span style=\"color:#a3b7a6\">${k}:</span> ${String(p[k])}</div>`).join('');
        layer.bindPopup(`<b>${name}</b><div style=\"margin-top:6px\">${rows}</div>`);
        layer.on('mouseover', ()=> layer.setStyle({weight:3}));
        layer.on('mouseout',  ()=> layer.setStyle({weight:2}));
      }
    });

    async function loadOhioPublic(){
      try{ const localResp = await fetch('ohio_public_hunting.geojson', {cache:'reload'}); if(localResp.ok){ const localJson = await localResp.json(); ohioPublic.addData(localJson); console.info('Loaded local ohio_public_hunting.geojson'); return; } }catch(e){ console.info('Local ohio_public_hunting.geojson not found'); }
      try{ const odnrResp = await fetch('https://gis2.ohiodnr.gov/ArcGIS/rest/services/OIT_Services/DNR_Fed_Lands_Nav_Base/MapServer/2/query?where=1%3D1&outFields=*&outSR=4326&f=geojson'); const odnrJson = await odnrResp.json(); ohioPublic.addData(odnrJson); console.info('Loaded ODNR fallback layer'); }catch(err){ console.warn('ODNR layer fetch failed', err); }
    }
    loadOhioPublic();

    /*******************
     * RADAR LAYERS     *
     *******************/
    const radarRain = L.tileLayer('https://tilecache.rainviewer.com/v2/radar/nowcast/256/{z}/{x}/{y}/2/1_1.png', { opacity: 0.6, attribution: 'RainViewer' });
    const radarNoaa = L.tileLayer.wms('https://opengeo.ncep.noaa.gov/geoserver/conus/conus_bref_qcd/ows?', { layers: 'conus_bref_qcd', format: 'image/png', transparent: true, opacity: 0.6, attribution: 'NOAA/NWS' });

    function setRadarSource(src){ const vis = document.getElementById('radarToggle').checked; map.removeLayer(radarRain); map.removeLayer(radarNoaa); if(!vis) return; if(src==='noaa') { radarNoaa.setOpacity(parseFloat(radarOpacity.value)); radarNoaa.addTo(map); } else { radarRain.setOpacity(parseFloat(radarOpacity.value)); radarRain.addTo(map); } localStorage.setItem('radar_src', src); }
    function setRadarVisibility(v){ document.getElementById('radarToggle').checked = v; localStorage.setItem('radar_vis', v? '1':'0'); setRadarSource(localStorage.getItem('radar_src')||'rainviewer'); }
    function setRadarOpacity(val){ const v=parseFloat(val); radarRain.setOpacity(v); radarNoaa.setOpacity(v); localStorage.setItem('radar_opacity', v.toString()); }

    // Add to layers control as toggles too
    const overlaysForControl = { 'Ohio Public Hunting': ohioPublic, 'Hunt Markers': markersLayer, 'My Drawings': drawnItems, 'My Track': trackLayer };
    L.control.layers({ 'Basic':basic, 'Satellite':satellite, 'Topographic':topo }, overlaysForControl, { position:'bottomleft' }).addTo(map);

    /*******************
     * BOTTOM MENU ACTIONS
     *******************/
    const btnFieldInfo = document.getElementById('toggleFieldInfo');
    const infoPanel = document.getElementById('infoPanel');
    const btnBasemap = document.getElementById('toggleBasemap');
    const btnLocate  = document.getElementById('menuLocate');
    const btnWaypoints = document.getElementById('menuWaypoints');
    const btnTrack = document.getElementById('menuTrack');
    const btnRadar = document.getElementById('menuRadar');
    const btnExport = document.getElementById('btnExport');
    const btnImport = document.getElementById('btnImport');
    const btnDelete = document.getElementById('btnDeleteMode');
    const fileInput = document.getElementById('fileImport');

    const sheetBg = document.getElementById('sheetBackdrop');
    const sheetMap = { basemap: document.getElementById('basemapSheet'), waypoints: document.getElementById('waypointsSheet'), track: document.getElementById('trackSheet'), radar: document.getElementById('radarSheet') };
    function openSheet(which){ Object.values(sheetMap).forEach(s=> s.classList.remove('show')); sheetBg.classList.add('show'); sheetMap[which].classList.add('show'); if(which==='waypoints') refreshWaypointsUI(); syncOverlayChecks(); syncBaseRadio(); }
    function closeSheets(){ sheetBg.classList.remove('show'); Object.values(sheetMap).forEach(s=> s.classList.remove('show')); }
    sheetBg.onclick = closeSheets;

    // Make entire .option row clickable (toggle inner input)
    document.querySelectorAll('.sheet .option').forEach(opt=>{
      opt.addEventListener('click', (e)=>{
        const input = opt.querySelector('input'); if(!input) return;
        if(input.type==='radio'){ input.checked = true; input.dispatchEvent(new Event('change', {bubbles:true})); }
        if(input.type==='checkbox'){ input.checked = !input.checked; input.dispatchEvent(new Event('change', {bubbles:true})); }
      });
    });

    // Basemap sheet wiring
    const radios = Array.from(document.querySelectorAll('input[name="basemap"]'));
    function syncBaseRadio(){ const k = localStorage.getItem(STORAGE_BASE) || 'basic'; const r = radios.find(r=>r.value===k); if(r) r.checked = true; }
    btnBasemap.onclick = ()=>{ openSheet('basemap'); };
    radios.forEach(r=> r.addEventListener('change', ()=>{ setBasemap(r.value); }));

    // Overlay toggles in the basemap sheet
    const ovlOhio = document.getElementById('ovlOhio');
    const ovlDraw = document.getElementById('ovlDraw');
    const ovlMarks = document.getElementById('ovlMarks');
    const ovlTrack = document.getElementById('ovlTrack');

    function syncOverlayChecks(){ ovlOhio.checked = map.hasLayer(ohioPublic); ovlDraw.checked = map.hasLayer(drawnItems); ovlMarks.checked = map.hasLayer(markersLayer); ovlTrack.checked = map.hasLayer(trackLayer); }
    ovlOhio.onchange = ()=> ovlOhio.checked ? ohioPublic.addTo(map) : map.removeLayer(ohioPublic);
    ovlDraw.onchange = ()=> ovlDraw.checked ? drawnItems.addTo(map) : map.removeLayer(drawnItems);
    ovlMarks.onchange = ()=> ovlMarks.checked ? markersLayer.addTo(map) : map.removeLayer(markersLayer);
    ovlTrack.onchange = ()=> ovlTrack.checked ? trackLayer.addTo(map) : map.removeLayer(trackLayer);

    // Waypoints
    btnWaypoints.onclick = ()=> openSheet('waypoints');

    // Track
    btnTrack.onclick = ()=> openSheet('track');
    document.getElementById('trkStartStop').onclick = ()=>{ if(watchId) stopTrack(); else startTrack(); };
    document.getElementById('trkClear').onclick = clearTrack; // Clear Track only
    document.getElementById('trkExport').onclick = exportGPX;

    // Radar button toggles visibility quickly, then opens sheet
    const radarToggle = document.getElementById('radarToggle');
    const radarOpacity = document.getElementById('radarOpacity');
    const radarSrcRadios = Array.from(document.querySelectorAll('input[name="radarSrc"]'));
    function restoreRadar(){ const vis = localStorage.getItem('radar_vis')==='1'; const src = localStorage.getItem('radar_src')||'rainviewer'; const op = parseFloat(localStorage.getItem('radar_opacity')||'0.6'); radarToggle.checked = vis; radarOpacity.value = op; const r = radarSrcRadios.find(r=>r.value===src); if(r) r.checked=true; setRadarOpacity(op); setRadarSource(src); }
    btnRadar.onclick = ()=>{ const wasVis = localStorage.getItem('radar_vis')==='1'; setRadarVisibility(!wasVis); restoreRadar(); openSheet('radar'); };
    radarToggle.onchange = ()=> setRadarVisibility(radarToggle.checked);
    radarOpacity.oninput = ()=> setRadarOpacity(radarOpacity.value);
    radarSrcRadios.forEach(r=> r.addEventListener('change', ()=> setRadarSource(r.value)));

    // Field Info toggle & position persistence
    const STORAGE_INFO_POS = 'ui_info_pos';
    const STORAGE_INFO_VIS = 'ui_info_visible';
    function setInfoVisible(v){ infoPanel.style.display = v? 'block':'none'; localStorage.setItem(STORAGE_INFO_VIS, v? '1':'0'); if(v){ updateSun(); updateTrackStats(); } }
    function getInfoVisible(){ return localStorage.getItem(STORAGE_INFO_VIS) === '1'; }
    document.getElementById('toggleFieldInfo').onclick = ()=> setInfoVisible(infoPanel.style.display==='none' || infoPanel.style.display==='');

    setInfoVisible(getInfoVisible());

    // Export / Import / Delete mode (bottom menu)
    btnExport.onclick = () => { const drawings = JSON.parse(localStorage.getItem(STORAGE_DRAW) || '{}'); const data = { drawings, markers: serializeMarkers(), track: trackPoints }; const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href=url; a.download='buckeyehunterhub-export.json'; a.click(); URL.revokeObjectURL(url); };
    btnImport.onclick = () => fileInput.click();
    fileInput.onchange = (ev) => { const f = ev.target.files[0]; if(!f) return; const r=new FileReader(); r.onload = () => { try{ const obj = JSON.parse(r.result);
        if(obj.drawings && (obj.drawings.geojson || obj.drawings.circles)){
          // replace drawings bundle
          localStorage.setItem(STORAGE_DRAW, JSON.stringify(obj.drawings));
          // clear and reload
          drawnItems.clearLayers(); segmentLabelsGroup.clearLayers(); restoreDraw();
        } else if(obj.type==='FeatureCollection' || obj.type==='Feature'){
          // legacy: add to drawings
          L.geoJSON(obj, {onEachFeature:(_,l)=> drawnItems.addLayer(l)});
          saveDraw();
        }
        if(obj.markers) deserializeMarkers(obj.markers);
        if(obj.track) { trackPoints = obj.track; trackLayer.setLatLngs(trackPoints.map(p=>[p.lat,p.lng])); saveTrack(); }
      } catch{ alert('Invalid JSON/GeoJSON file'); } finally { ev.target.value=''; } }; r.readAsText(f); };
    btnDelete.onclick = () => { deleteMode = !deleteMode; btnDelete.textContent = `Delete: ${deleteMode? 'On':'Off'}`; };

    // Locate
    btnLocate.onclick = ()=>{ if(!navigator.geolocation){ alert('Geolocation not supported'); return; } navigator.geolocation.getCurrentPosition(pos=>{ const latlng=[pos.coords.latitude, pos.coords.longitude]; map.setView(latlng, 15); }, err=> alert('Location error: '+err.message), { enableHighAccuracy:true, timeout:8000 }); };

    // Draggable Field Info
    function makeDraggable(el, handle, storageKey){ let sx=0, sy=0, sl=0, st=0, dragging=false; const start=(x,y)=>{ dragging=true; sx=x; sy=y; const r=el.getBoundingClientRect(); sl=r.left; st=r.top; document.addEventListener('mousemove',move); document.addEventListener('mouseup',up); document.addEventListener('touchmove',tmove,{passive:false}); document.addEventListener('touchend',up); }; const down=(e)=>{ const p=point(e); start(p.x,p.y); e.preventDefault(); }; const tdown=(e)=>{ const p=point(e); start(p.x,p.y); }; const move=(e)=>{ if(!dragging) return; const p=point(e); apply(sl+p.x-sx, st+p.y-sy); e.preventDefault(); }; const tmove=(e)=>{ if(!dragging) return; const p=point(e); apply(sl+p.x-sx, st+p.y-sy); e.preventDefault(); }; const up=()=>{ dragging=false; document.removeEventListener('mousemove',move); document.removeEventListener('mouseup',up); document.removeEventListener('touchmove',tmove); document.removeEventListener('touchend',up); savePos(); }; function point(e){ if(e.touches && e.touches[0]) return {x:e.touches[0].clientX,y:e.touches[0].clientY}; return {x:e.clientX,y:e.clientY}; } function apply(l,t){ const vw=innerWidth, vh=innerHeight; const w=el.offsetWidth, h=el.offsetHeight; l=Math.max(4,Math.min(vw-w-4,l)); t=Math.max(60,Math.min(vh-h-4,t)); el.style.left=l+'px'; el.style.top=t+'px'; } function savePos(){ const r=el.getBoundingClientRect(); localStorage.setItem(storageKey, JSON.stringify({left:r.left, top:r.top})); } try{ const s=JSON.parse(localStorage.getItem(storageKey)||'null'); if(s){ el.style.left=s.left+'px'; el.style.top=s.top+'px'; } }catch{} handle.addEventListener('mousedown',down); handle.addEventListener('touchstart',tdown,{passive:false}); }
    makeDraggable(infoPanel, document.getElementById('infoHandle'), 'ui_info_pos');

    /*******************
     * LAYERS CONTROL   *
     *******************/
    L.control.layers(
      { 'Basic':basic, 'Satellite':satellite, 'Topographic':topo },
      { 'Ohio Public Hunting': ohioPublic, 'Hunt Markers': markersLayer, 'My Drawings': drawnItems, 'My Track': trackLayer },
      { position:'bottomleft' }
    ).addTo(map);

    /*******************
     * SUN INFO         *
     *******************/
    function updateSun(){ const c = map.getCenter(); const now = new Date(); const t = SunCalc.getTimes(now, c.lat, c.lng); const fmt = d => d ? d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}) : '--:--'; document.getElementById('pSunrise').textContent = fmt(t.sunrise); document.getElementById('pSunset').textContent  = fmt(t.sunset); const mins = Math.max(0, (t.sunset - t.sunrise)/60000|0); document.getElementById('pDay').textContent = `${Math.floor(mins/60)}h ${mins%60}m`; }
    updateSun(); map.on('moveend', updateSun);
  </script>
</body>
</html>
