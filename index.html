<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Buckeye Hunter Hub — Mobile Hunting Map</title>
  
  <!-- Leaflet core -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  
  <!-- Leaflet.draw -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css"/>
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>

  <!-- SunCalc for sun/moon -->
  <script src="https://unpkg.com/suncalc@1.9.0/suncalc.js"></script>

  <style>
    :root{
      --bg:#0b1a0f;        /* deep forest */
      --panel:#101f14;     /* card */
      --muted:#1a2b1f;
      --accent:#6dbc5d;    /* green */
      --text:#e7f1e8;
      --subtle:#a3b7a6;
      --danger:#f87171;
      --shadow:0 12px 30px rgba(0,0,0,.35);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
    }
    html,body,#app{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui,Roboto,Arial,sans-serif}
    /* Full screen map on mobile */
    #map{position:fixed;inset:0;height:100dvh}
    #map.placing{cursor: crosshair}

    /* Info panel (smaller + draggable) */
    .panel{position:fixed;left:12px;top:80px;z-index:1000;background:var(--panel);border:1px solid #203325;border-radius:12px;box-shadow:var(--shadow);padding:8px 10px;min-width:180px;max-width:260px}
    .panel h3{margin:0 0 6px;font-size:14px;display:flex;align-items:center;gap:8px;cursor:move}
    .row{display:flex;align-items:center;justify-content:space-between;gap:8px;padding:4px 0;border-bottom:1px solid #1d3323}
    .row:last-child{border-bottom:0}
    .tag{font-size:11px;color:var(--subtle)}

    /* Bottom main menu */
    .main-menu{position:fixed;left:0;right:0;bottom:0;z-index:1200;display:flex;gap:8px;justify-content:space-around;align-items:center;padding:10px 12px calc(10px + var(--safe-bottom));background:linear-gradient(180deg,rgba(11,26,15,.1),rgba(11,26,15,.85));backdrop-filter:blur(8px);border-top:1px solid #203325;flex-wrap:wrap}
    .main-menu button{flex:1;max-width:140px;padding:10px;border:1px solid #25432b;border-radius:12px;background:#14271a;color:var(--text);font-size:14px;cursor:pointer;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .wind-btn{display:flex;align-items:center;gap:8px;max-width:260px}
    #windText{font-size:12px}
    .wind-arrow{width:0;height:0;border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:12px solid #e7f1e8;display:inline-block;transform:rotate(0deg)}

    /* Sheets (backdrop + panel) */
    .backdrop{position:fixed;inset:0;background:rgba(0,0,0,.35);z-index:1199;display:none}
    .backdrop.show{display:block}
    .sheet{position:fixed;left:0;right:0;bottom:0;z-index:1200;background:var(--panel);border-top:1px solid #203325;border-radius:16px 16px 0 0;box-shadow:var(--shadow);transform:translateY(110%);transition:transform .25s ease}
    .sheet.show{transform:translateY(0)}
    .sheet .grab{width:36px;height:4px;border-radius:999px;background:#2b4231;margin:8px auto}
    .sheet .option{display:flex;align-items:center;justify-content:space-between;padding:12px 16px;border-top:1px solid #1d3323;cursor:pointer}
    .sheet h4{margin:6px 16px 8px;font-size:14px;color:var(--subtle)}
    .sheet .content{padding:4px 16px 14px}
    .sheet .row{border:0}
    .sheet input[type="text"], .sheet input[type="number"], .sheet input[type="search"], .sheet select{width:100%;padding:8px 10px;border-radius:10px;border:1px solid #25432b;background:#14271a;color:var(--text)}
    .btn{padding:8px 12px;border:1px solid #25432b;border-radius:10px;background:#14271a;color:var(--text);cursor:pointer}
    .btn.danger{border-color:#5a2222;background:#331616}

    /* Waypoints list */
    .wp-list{max-height:38vh;overflow:auto;margin-top:6px}
    .item{display:grid;grid-template-columns:auto 1fr auto auto;gap:10px;align-items:center;padding:8px 0;border-bottom:1px solid #1d3323}
    .emoji{font-size:18px}
    .name{min-width:0}
    .actions button{margin-left:8px}

    /* Segment / total distance labels */
    .seglabel{background:rgba(16,31,20,.92);border:1px solid #203325;border-radius:10px;padding:2px 6px;font-size:11px;color:var(--text);box-shadow:var(--shadow)}

    /* Hunt score list */
    .score-list{max-height:48vh;overflow:auto;margin-top:8px}
    .score-item{display:grid;grid-template-columns:56px 1fr auto;gap:10px;align-items:center;padding:8px 0;border-bottom:1px solid #1d3323}
    .bar{height:8px;background:#1f3b29;border:1px solid #2a4a32;border-radius:8px;overflow:hidden}
    .bar > span{display:block;height:100%;background:#6dbc5d}

    /* --- Mobile tweaks --- */
    @media (max-width:640px){
      .panel{left:8px;top:72px}
      /* Make bottom bar a horizontal scroller so button text stays visible */
      .main-menu{gap:10px;justify-content:flex-start;flex-wrap:nowrap;overflow-x:auto;-webkit-overflow-scrolling:touch;padding:10px 12px calc(12px + var(--safe-bottom))}
      .main-menu::-webkit-scrollbar{height:6px}
      .main-menu button{flex:0 0 auto;min-width:132px;max-width:none;font-size:14px;padding:10px 12px}
      .wind-btn{min-width:180px}
      #windText{font-size:12.5px}
    }

    @supports (height: 100svh){ #map{height:100svh} }
    /* Always-visible county name labels */
  .county-label{position:absolute; transform:translate(-50%,-50%); background:rgba(16,31,20,.75); border:1px solid #203325; color:#e7f1e8; padding:2px 6px; border-radius:10px; font-weight:600; letter-spacing:.3px; white-space:nowrap; text-shadow:0 1px 0 rgba(0,0,0,.5); pointer-events:none; user-select:none}
</style>
</head>
<body>
  <div id="app">
    <div id="map"></div>

    <!-- Field Info panel (hidden by default; draggable) -->
    <section class="panel" id="infoPanel" style="display:none;">
      <h3 id="infoHandle">📋 Field Info</h3>
      <div class="row"><span>Sunrise</span><strong id="pSunrise" class="tag">--:--</strong></div>
      <div class="row"><span>Sunset</span><strong id="pSunset" class="tag">--:--</strong></div>
      <div class="row"><span>Day Length</span><strong id="pDay" class="tag">--h --m</strong></div>
      <div class="row"><span>Track Distance</span><strong id="pTrkDist" class="tag">0 m</strong></div>
      <div class="row"><span>Track Duration</span><strong id="pTrkDur" class="tag">0:00</strong></div>
      <p class="tag">Tip: start the Track Recorder to populate distance & duration.</p>
    </section>

    <!-- Bottom main menu -->
    <nav class="main-menu" id="mainMenu">
      <button id="toggleFieldInfo">Field Info</button>
      <button id="menuMoon">Moon Phases</button>
      <button id="menuScore">Hunt Score</button>
      <button id="menuWind" class="wind-btn"><span class="wind-arrow" id="windArrow"></span><span id="windText">Wind: --</span></button>
      <button id="menuWaypoints">Waypoints</button>
      <button id="menuTrack">Track</button>
      <button id="menuRadar">Radar</button>
      <button id="toggleBasemap">Basemap</button>
      <button id="btnExport">Export</button>
      <button id="btnImport">Import</button>
      <button id="btnDeleteMode">Delete: Off</button>
      <button id="menuLocate">Locate Me</button>
      <input type="file" id="fileImport" accept=".json,.geojson,application/json,application/geo+json" style="display:none" />
    </nav>

    <!-- Shared backdrop for sheets -->
    <div class="backdrop" id="sheetBackdrop"></div>

    <!-- Basemap & Overlays sheet -->
    <div class="sheet" id="basemapSheet" aria-hidden="true">
      <div class="grab"></div>
      <h4>Basemap</h4>
      <div class="option" data-radio="basemap" data-value="basic"><span>Basic</span><input type="radio" name="basemap" value="basic"></div>
      <div class="option" data-radio="basemap" data-value="satellite"><span>Satellite</span><input type="radio" name="basemap" value="satellite"></div>
      <div class="option" data-radio="basemap" data-value="topo"><span>Topographic</span><input type="radio" name="basemap" value="topo"></div>
      <h4 style="margin-top:10px">Overlays</h4>
      <div class="option"><span>Ohio Public Hunting</span><input id="ovlOhio" type="checkbox"></div>
      <div class="option"><span>Ohio Counties</span><input id="ovlCounties" type="checkbox"></div>
      <div class="option"><span>My Drawings</span><input id="ovlDraw" type="checkbox"></div>
      <div class="option"><span>Hunt Markers</span><input id="ovlMarks" type="checkbox"></div>
      <div class="option"><span>My Track</span><input id="ovlTrack" type="checkbox"></div>
    </div>

    <!-- Waypoints + Shapes manager sheet -->
    <div class="sheet" id="waypointsSheet" aria-hidden="true">
      <div class="grab"></div>
      <h4>Waypoints & Shapes</h4>
      <div class="content">
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-bottom:8px">
          <select id="wpType">
            <option value="stand">Tree Stand</option>
            <option value="feeder">Feeder</option>
            <option value="camera">Trail Camera</option>
            <option value="scrape">Scrape</option>
            <option value="rub">Rub</option>
            <option value="water">Water Source</option>
          </select>
          <input id="wpName" type="text" placeholder="Name (optional)" />
        </div>
        <div style="display:flex; gap:8px; margin-bottom:10px">
          <button class="btn" id="wpAddCenter">Add at Map Center</button>
          <button class="btn" id="wpAddGPS">Add from GPS</button>
        </div>
        <input id="wpSearch" type="search" placeholder="Search by name or type" />
        <div class="wp-list" id="wpList"></div>
      </div>
    </div>

    <!-- Track recorder sheet -->
    <div class="sheet" id="trackSheet" aria-hidden="true">
      <div class="grab"></div>
      <h4>Track Recorder</h4>
      <div class="content">
        <div class="row"><span>Status</span><strong id="trkStatus" class="tag">Stopped</strong></div>
        <div class="row"><span>Points</span><strong id="trkPts" class="tag">0</strong></div>
        <div class="row"><span>Distance</span><strong id="trkDist" class="tag">0 m</strong></div>
        <div class="row"><span>Duration</span><strong id="trkDur" class="tag">0:00</strong></div>
        <label style="display:flex;align-items:center;gap:8px;margin-top:8px"><input type="checkbox" id="trkFollow"/> Auto-center while recording</label>
        <div style="display:flex;gap:8px;margin-top:10px">
          <button class="btn" id="trkStartStop">Start</button>
          <button class="btn danger" id="trkClear">Clear Track</button>
          <button class="btn" id="trkExport">Export GPX</button>
        </div>
      </div>
    </div>

    <!-- Radar sheet -->
    <div class="sheet" id="radarSheet" aria-hidden="true">
      <div class="grab"></div>
      <h4>Weather Radar</h4>
      <div class="content">
        <div class="option"><span>Visible</span><input id="radarToggle" type="checkbox"></div>
        <div class="option"><span>Source</span>
          <div>
            <label style="margin-right:10px"><input type="radio" name="radarSrc" value="rainviewer"> RainViewer</label>
            <label><input type="radio" name="radarSrc" value="noaa"> NOAA</label>
          </div>
        </div>
        <div class="option"><span>Opacity</span><input id="radarOpacity" type="range" min="0" max="1" step="0.05" value="0.6" style="width:160px"></div>
        <p class="tag">Tip: Tap the Radar button to toggle visibility quickly; use this sheet to change source & opacity.</p>
      </div>
    </div>

    <!-- Wind & Scent cone sheet -->
    <div class="sheet" id="windSheet" aria-hidden="true">
      <div class="grab"></div>
      <h4>Wind & Scent Cone</h4>
      <div class="content">
        <div class="row"><span>Wind</span><button class="btn" id="windRefresh">Refresh now</button></div>
        <div class="option"><span>Show scent cone</span><input id="coneToggle" type="checkbox"></div>
        <div class="option"><span>Width</span><input id="coneWidth" type="range" min="20" max="120" step="5" value="60" style="width:160px"></div>
        <div class="option"><span>Length scale</span><input id="coneScale" type="range" min="0.5" max="2" step="0.1" value="1" style="width:160px"></div>
        <div class="option"><span>Anchor</span>
          <div>
            <label style="margin-right:10px"><input type="radio" name="coneAnchor" value="gps" checked> GPS</label>
            <label><input type="radio" name="coneAnchor" value="center"> Map center</label>
          </div>
        </div>
        <p class="tag">Length scales with wind speed. Width spreads the cone. Anchor sets the origin.</p>
      </div>
    </div>

    <!-- Moon phases sheet -->
    <div class="sheet" id="moonSheet" aria-hidden="true">
      <div class="grab"></div>
      <h4>Moon Phases</h4>
      <div class="content" id="moonContent">
        <!-- Filled by JS: current phase + next 7 days -->
      </div>
    </div>

    <!-- Hunt score sheet -->
    <div class="sheet" id="scoreSheet" aria-hidden="true">
      <div class="grab"></div>
      <h4>Hunt Score (next 48h)</h4>
      <div class="content">
        <div class="option"><span>Location</span>
          <div>
            <label style="margin-right:10px"><input type="radio" name="scoreLoc" value="gps" checked> GPS</label>
            <label><input type="radio" name="scoreLoc" value="center"> Map center</label>
          </div>
        </div>
        <div class="option"><span>Refresh data</span><button class="btn" id="scoreRefresh">Update</button></div>
        <div class="score-list" id="scoreList"></div>
        <p class="tag">Score blends wind, temp, precip, light, and moon. Higher is better; dusk/dawn often peak. Use with local knowledge.</p>
      </div>
    </div>

  </div>

  <script>
    /*******************
     * MAP & BASELAYERS *
     *******************/
    const map = L.map('map').setView([40.4173, -82.9071], 7);
    const basic = L.tileLayer('https://api.maptiler.com/maps/basic/{z}/{x}/{y}.png?key=VLOZCnjQYBtgpZ3BXBK3', { attribution: '&copy; MapTiler & OpenStreetMap contributors' }).addTo(map);
    const satellite = L.tileLayer('https://api.maptiler.com/tiles/satellite-v2/{z}/{x}/{y}.jpg?key=VLOZCnjQYBtgpZ3BXBK3', { attribution: '&copy; MapTiler' });
    const topo = L.tileLayer('https://api.maptiler.com/maps/topo/{z}/{x}/{y}.png?key=VLOZCnjQYBtgpZ3BXBK3', { attribution: '&copy; MapTiler & OpenStreetMap contributors' });

    const baseByKey = { basic, satellite, topo };
    const STORAGE_BASE = 'ui_basemap_key';
    function setBasemap(key){ Object.values(baseByKey).forEach(l=> map.removeLayer(l)); baseByKey[key].addTo(map); localStorage.setItem(STORAGE_BASE, key); }
    (function restoreBasemap(){ const k = localStorage.getItem(STORAGE_BASE); if(k && baseByKey[k]) setBasemap(k); })();

    /*******************
     * DRAWING LAYERS  *
     *******************/
    const drawnItems = new L.FeatureGroup().addTo(map);
    const drawControl = new L.Control.Draw({ position:'topleft', edit:{ featureGroup: drawnItems }, draw:{ circle:true } });
    map.addControl(drawControl);

    const STORAGE_DRAW = 'bhh_drawings_v5';

    function featureTypeFromLayer(l){
      if(l instanceof L.Circle) return 'circle';
      if(l instanceof L.Rectangle) return 'rectangle';
      if(l instanceof L.Polygon && !(l instanceof L.Rectangle)) return 'polygon';
      if(l instanceof L.Polyline && !(l instanceof L.Polygon)) return 'polyline';
      return 'shape';
    }

    function defaultShapeName(type){
      const base = {polyline:'Line', polygon:'Area', rectangle:'Plot', circle:'Circle', shape:'Shape'}[type] || 'Shape';
      let n=1; drawnItems.eachLayer(l=>{ if(featureTypeFromLayer(l)===type) n++; });
      return `${base} ${n}`;
    }

    function saveDraw(){
      const geojson = { type:'FeatureCollection', features:[] };
      const circles = [];
      drawnItems.eachLayer(l=>{
        const type = featureTypeFromLayer(l);
        if(type==='circle'){
          const c = l.getLatLng();
          circles.push({ lat:c.lat, lng:c.lng, radius:l.getRadius(), properties:{ name:l._bhhName || defaultShapeName('circle'), shapeType:'circle' } });
        } else {
          const f = l.toGeoJSON();
          f.properties = Object.assign({}, f.properties||{}, { name: l._bhhName || defaultShapeName(type), shapeType:type });
          geojson.features.push(f);
        }
      });
      const bundle = { geojson, circles };
      localStorage.setItem(STORAGE_DRAW, JSON.stringify(bundle));
    }

    function restoreDraw(){
      const raw = localStorage.getItem(STORAGE_DRAW);
      if(!raw){ return; }
      try{
        const data = JSON.parse(raw);
        if(data && data.geojson){
          L.geoJSON(data.geojson, { onEachFeature:(feat,layer)=>{
            layer._bhhName = (feat.properties && feat.properties.name) || defaultShapeName(featureTypeFromLayer(layer));
            drawnItems.addLayer(layer);
            if(layer instanceof L.Polyline && !(layer instanceof L.Polygon)) { labelPolylineSegments(layer); updatePolylineTotalLabel(layer); }
          }});
          (data.circles||[]).forEach(c=>{
            const layer = L.circle([c.lat,c.lng], { radius:c.radius });
            layer._bhhName = (c.properties && c.properties.name) || defaultShapeName('circle');
            drawnItems.addLayer(layer);
          });
        } else if(data.type==='FeatureCollection'){ // legacy
          L.geoJSON(data, { onEachFeature:(_,layer)=>{ layer._bhhName = defaultShapeName(featureTypeFromLayer(layer)); drawnItems.addLayer(layer); if(layer instanceof L.Polyline && !(layer instanceof L.Polygon)) { labelPolylineSegments(layer); updatePolylineTotalLabel(layer); } } });
        }
      }catch(e){ console.warn('restore drawings failed', e); }
    }

    restoreDraw();

    map.on(L.Draw.Event.CREATED, e=>{
      const layer = e.layer;
      const type = e.layerType || featureTypeFromLayer(layer);
      // name prompt
      const suggested = defaultShapeName(type);
      const nm = prompt(`Name this ${type}:`, suggested);
      layer._bhhName = (nm===null || nm.trim()==='') ? suggested : nm.trim();
      drawnItems.addLayer(layer);
      if(type==='polyline') { labelPolylineSegments(layer); updatePolylineTotalLabel(layer); }
      saveDraw();
      refreshWaypointsUI();
    });
    map.on(L.Draw.Event.EDITED, e=>{ e.layers.eachLayer(l=>{ if(l instanceof L.Polyline && !(l instanceof L.Polygon)) { relabelPolyline(l); updatePolylineTotalLabel(l); } }); saveDraw(); refreshWaypointsUI(); });
    map.on(L.Draw.Event.DELETED, e=>{ e.layers.eachLayer(l=> { removeSegLabels(l); removeTotalLabel(l); }); saveDraw(); refreshWaypointsUI(); });

    /*******************
     * SEGMENT + TOTAL LABELS FOR POLYLINES
     *******************/
    const segmentLabelsGroup = L.layerGroup().addTo(map);

    function fmtFeetMiles(m){
      const ft = m * 3.28084;
      if(m >= 1609.344) return (m/1609.344).toFixed(2) + ' mi';
      return Math.round(ft) + ' ft';
    }

    function removeSegLabels(layer){
      if(layer._segLabels){ layer._segLabels.forEach(lbl=> segmentLabelsGroup.removeLayer(lbl)); layer._segLabels = null; }
    }
    function removeTotalLabel(layer){ if(layer._totalLabel){ segmentLabelsGroup.removeLayer(layer._totalLabel); layer._totalLabel=null; } }

    function labelPolylineSegments(layer){
      removeSegLabels(layer);
      const latlngs = layer.getLatLngs();
      const pts = Array.isArray(latlngs[0]) ? latlngs[0] : latlngs; // simple polyline
      const labels=[];
      for(let i=1;i<pts.length;i++){
        const a = pts[i-1], b = pts[i];
        const d = map.distance(a, b);
        const mid = L.latLng((a.lat+b.lat)/2, (a.lng+b.lng)/2);
        const marker = L.marker(mid, { interactive:false, icon: L.divIcon({ className:'', html:`<div class="seglabel">${fmtFeetMiles(d)}</div>` }) });
        marker.addTo(segmentLabelsGroup);
        labels.push(marker);
      }
      layer._segLabels = labels;
    }

    function polylineTotalDistance(layer){
      const latlngs = layer.getLatLngs();
      const pts = Array.isArray(latlngs[0]) ? latlngs[0] : latlngs;
      let d=0; for(let i=1;i<pts.length;i++){ d += map.distance(pts[i-1], pts[i]); } return d;
    }

    function updatePolylineTotalLabel(layer){
      removeTotalLabel(layer);
      const latlngs = layer.getLatLngs();
      const pts = Array.isArray(latlngs[0]) ? latlngs[0] : latlngs;
      if(pts.length<2) return;
      const a = pts[pts.length-2], b = pts[pts.length-1];
      const anchor = L.latLng((a.lat*0.3 + b.lat*0.7), (a.lng*0.3 + b.lng*0.7));
      const total = fmtFeetMiles(polylineTotalDistance(layer));
      const marker = L.marker(anchor, { interactive:false, icon: L.divIcon({ className:'', html:`<div class="seglabel"><b>Total:</b> ${total}</div>` }) });
      marker.addTo(segmentLabelsGroup);
      layer._totalLabel = marker;
    }

    function relabelPolyline(layer){ labelPolylineSegments(layer); }

    /*******************
     * MARKERS (WAYPOINTS)
     *******************/
    const markersLayer = L.featureGroup().addTo(map);
    const STORAGE_MARK = 'bhh_markers_v3';
    const IS_MOBILE = matchMedia('(max-width:640px)').matches;
    const ICON_SZ = IS_MOBILE ? 28 : 32;
    const FONT_SZ = IS_MOBILE ? 16 : 18;

    function makeIcon(bg,emoji){
      return L.divIcon({
        className:'',
        html:`<div style="background:${bg};border:2px solid #333;border-radius:50%;width:${ICON_SZ}px;height:${ICON_SZ}px;display:flex;align-items:center;justify-content:center;font-size:${FONT_SZ}px;color:#fff;box-shadow:0 2px 6px rgba(0,0,0,.4);">${emoji}</div>`,
        iconSize:[ICON_SZ,ICON_SZ], iconAnchor:[ICON_SZ/2, ICON_SZ], popupAnchor:[0, -ICON_SZ*0.9]
      });
    }

    const markerTypes = {
      stand:{label:'Tree Stand', emoji:'🎯', icon:makeIcon('#2563eb','🎯')},
      feeder:{label:'Feeder', emoji:'🍽️', icon:makeIcon('#16a34a','🍽️')},
      camera:{label:'Trail Camera', emoji:'📷', icon:makeIcon('#111827','📷')},
      scrape:{label:'Scrape', emoji:'🦌', icon:makeIcon('#6d28d9','🦌')},
      rub:{label:'Rub', emoji:'🪵', icon:makeIcon('#b45309','🪵')},
      water:{label:'Water Source', emoji:'💧', icon:makeIcon('#0891b2','💧')}
    };

    let activeType=null; let deleteMode=false;
    function setActiveType(type){ activeType=type; document.getElementById('map').classList.toggle('placing', !!type); }

    function uid(){ return Date.now().toString(36)+Math.random().toString(36).slice(2,7); }
    function defaultName(type){ const base = markerTypes[type]?.label || 'Marker'; let n = 1; markersLayer.eachLayer(m=>{ if(m.options.type===type) n++; }); return `${base} ${n}`; }

    function addMarker(latlng, type, name, id){
      const cfg = markerTypes[type] || {label:'Marker', emoji:'📍', icon:makeIcon('#555','📍')};
      const markerId = id || uid();
      const markerName = name || defaultName(type);
      const m = L.marker(latlng, { icon: cfg.icon, draggable:true, type, id: markerId, name: markerName });
      const setPopup = () => m.bindPopup(`<b>${m.options.name}</b><div class=\"tag\">${cfg.label}</div><br><button class=\"del\">Delete</button>`, {autoPan:false});
      setPopup();
      m.on('dragend', saveMarkers);
      m.on('click', () => { if(deleteMode){ markersLayer.removeLayer(m); saveMarkers(); refreshWaypointsUI(); } });
      m.on('popupopen', (e)=>{ const btn = e.popup.getElement().querySelector('button.del'); if(btn) btn.addEventListener('click', ()=> { markersLayer.removeLayer(m); saveMarkers(); refreshWaypointsUI(); }); });
      markersLayer.addLayer(m);
      saveMarkers();
      return m;
    }

    function serializeMarkers(){ const list=[]; markersLayer.eachLayer(m=>{ const {lat,lng}=m.getLatLng(); list.push({id:m.options.id, name:m.options.name, type:m.options.type||'marker', lat, lng}); }); return list; }
    function deserializeMarkers(list){ markersLayer.clearLayers(); (list||[]).forEach(m=> addMarker([m.lat,m.lng], m.type, m.name, m.id)); }
    function saveMarkers(){ localStorage.setItem(STORAGE_MARK, JSON.stringify(serializeMarkers())); }
    ;(function restoreMarkers(){ try{ const raw=localStorage.getItem(STORAGE_MARK); if(raw) deserializeMarkers(JSON.parse(raw)); }catch(e){} })();

    map.on('click', e=>{ if(!activeType) return; addMarker(e.latlng, activeType); setActiveType(null); refreshWaypointsUI(); });

    /*******************
     * WAYPOINTS & SHAPES LIST UI
     *******************/
    const wpList = document.getElementById('wpList');
    const wpSearch = document.getElementById('wpSearch');
    const wpType = document.getElementById('wpType');
    const wpName = document.getElementById('wpName');

    document.getElementById('wpAddCenter').onclick = ()=>{ const t=wpType.value; const n=wpName.value||undefined; addMarker(map.getCenter(), t, n); refreshWaypointsUI(); wpName.value=''; };
    document.getElementById('wpAddGPS').onclick = ()=>{ if(!navigator.geolocation){ alert('Geolocation not supported'); return; } navigator.geolocation.getCurrentPosition(pos=>{ const t=wpType.value; const n=wpName.value||undefined; addMarker([pos.coords.latitude, pos.coords.longitude], t, n); refreshWaypointsUI(); wpName.value=''; }, err=> alert('Location error: '+err.message), {enableHighAccuracy:true, timeout:8000}); };

    function gatherShapes(){
      const arr=[];
      drawnItems.eachLayer(l=>{
        const type = featureTypeFromLayer(l);
        let center = l.getBounds ? l.getBounds().getCenter() : (l.getLatLng ? l.getLatLng() : map.getCenter());
        arr.push({ kind:'shape', type, name: l._bhhName || defaultShapeName(type), layer:l, center });
      });
      return arr;
    }

    function getWaypoints(){
      const pts=[];
      markersLayer.eachLayer(m=>{ const {lat,lng}=m.getLatLng(); pts.push({ kind:'wp', id:m.options.id, name:m.options.name, type:m.options.type, lat, lng, layer:m }); });
      return pts;
    }

    function emojiFor(item){
      if(item.kind==='shape'){
        return ({polyline:'📏', polygon:'⬠', rectangle:'▭', circle:'◯'})[item.type] || '⬣';
      }
      return markerTypes[item.type]?.emoji || '📍';
    }

    function labelFor(item){
      if(item.kind==='shape'){
        return ({polyline:'Line', polygon:'Area', rectangle:'Plot', circle:'Circle'})[item.type] || 'Shape';
      }
      return markerTypes[item.type]?.label || 'Marker';
    }

    function allItems(){ return [...getWaypoints(), ...gatherShapes()]; }

    function refreshWaypointsUI(){
      const q = (wpSearch.value||'').toLowerCase();
      const items = allItems().filter(w=> !q || (w.name && w.name.toLowerCase().includes(q)) || (labelFor(w).toLowerCase().includes(q)));
      wpList.innerHTML = items.map((w,i)=>`
        <div class="item" data-kind="${w.kind}" data-idx="${i}">
          <div class="emoji">${emojiFor(w)}</div>
          <div class="name"><input type="text" value="${(w.name||'').replace(/&/g,'&amp;').replace(/"/g,'&quot;')}"/></div>
          <div class="actions"><button class="btn fly">Fly</button></div>
          <div class="actions"><button class="btn danger del">Delete</button></div>
        </div>`).join('') || '<p class="tag" style="margin-top:8px">No items yet.</p>';
    }

    wpList.addEventListener('click', (e)=>{
      const item = e.target.closest('.item'); if(!item) return;
      const idx = parseInt(item.dataset.idx,10);
      const items = allItems(); const obj = items[idx]; if(!obj) return;
      if(e.target.classList.contains('fly')){
        if(obj.kind==='wp'){ map.setView([obj.lat, obj.lng], Math.max(map.getZoom(), 16)); obj.layer.openPopup(); }
        else { if(obj.layer.getBounds){ map.fitBounds(obj.layer.getBounds(), { maxZoom: 18 }); } else if(obj.center){ map.setView(obj.center, 17); } }
      }
      if(e.target.classList.contains('del')){
        if(obj.kind==='wp'){ markersLayer.removeLayer(obj.layer); saveMarkers(); }
        else { removeSegLabels(obj.layer); removeTotalLabel(obj.layer); drawnItems.removeLayer(obj.layer); saveDraw(); }
        refreshWaypointsUI();
      }
    });

    wpList.addEventListener('input', (e)=>{
      const item = e.target.closest('.item'); if(!item) return; const idx = parseInt(item.dataset.idx,10); const items = allItems(); const obj = items[idx]; if(!obj) return;
      if(e.target.type==='text'){
        const val = e.target.value;
        if(obj.kind==='wp'){ obj.layer.options.name = val; const cfg = markerTypes[obj.layer.options.type] || {label:'Marker'}; obj.layer.bindPopup(`<b>${obj.layer.options.name}</b><div class=\"tag\">${cfg.label}</div><br><button class=\"del\">Delete</button>`); saveMarkers(); }
        else { obj.layer._bhhName = val; saveDraw(); }
      }
    });

    /*******************
     * TRACK RECORDER   *
     *******************/
    const trackLayer = L.polyline([], { color:'#22d3ee', weight:4, opacity:0.9 }).addTo(map);
    const STORAGE_TRK = 'bhh_track_v1';
    let trackPoints = []; // {lat,lng,t}
    let watchId = null; let startTime = null; let lastPoint = null;

    function loadTrack(){ try{ const raw=localStorage.getItem(STORAGE_TRK); if(raw){ trackPoints = JSON.parse(raw)||[]; trackLayer.setLatLngs(trackPoints.map(p=> [p.lat,p.lng])); } }catch{}; updateTrackStats(); }
    function saveTrack(){ localStorage.setItem(STORAGE_TRK, JSON.stringify(trackPoints)); updateTrackStats(); }

    function appendPoint(lat,lng,t){ const pt = {lat,lng,t: t||Date.now()}; if(lastPoint){ const d = map.distance([lastPoint.lat,lastPoint.lng],[lat,lng]); if(d < 3) return; } trackPoints.push(pt); lastPoint = pt; trackLayer.addLatLng([lat,lng]); saveTrack(); }

    function trackDistance(){ let d=0; for(let i=1;i<trackPoints.length;i++){ d += map.distance([trackPoints[i-1].lat,trackPoints[i-1].lng],[trackPoints[i].lat,trackPoints[i].lng]); } return d; }
    function updateTrackStats(){ const pts = trackPoints.length; const dist = trackDistance(); document.getElementById('trkPts').textContent = pts; const distText = dist>1609.344 ? (dist/1609.344).toFixed(2)+' mi' : Math.round(dist*3.28084)+' ft'; document.getElementById('trkDist').textContent = distText; const durMs = startTime ? (Date.now()-startTime) : (trackPoints.length? (trackPoints[trackPoints.length-1].t - trackPoints[0].t):0); const mm = Math.floor(durMs/60000), ss=(Math.floor(durMs/1000)%60).toString().padStart(2,'0'); document.getElementById('trkDur').textContent = `${mm}:${ss}`; document.getElementById('pTrkDist').textContent = distText; document.getElementById('pTrkDur').textContent = `${mm}:${ss}`; }

    function startTrack(){ if(!navigator.geolocation){ alert('Geolocation not supported'); return; } if(watchId) return; document.getElementById('trkStatus').textContent = 'Recording'; document.getElementById('trkStartStop').textContent = 'Stop'; startTime = Date.now(); watchId = navigator.geolocation.watchPosition(pos=>{ const {latitude, longitude} = pos.coords; appendPoint(latitude, longitude, Date.now()); if(document.getElementById('trkFollow').checked){ map.setView([latitude, longitude], Math.max(map.getZoom(), 16)); } }, err=>{ console.warn('track error', err); }, { enableHighAccuracy:true, maximumAge:5000 }); }
    function stopTrack(){ if(!watchId) return; navigator.geolocation.clearWatch(watchId); watchId=null; document.getElementById('trkStatus').textContent = 'Stopped'; document.getElementById('trkStartStop').textContent = 'Start'; updateTrackStats(); }
    function clearTrack(){ stopTrack(); trackPoints=[]; lastPoint=null; trackLayer.setLatLngs([]); saveTrack(); }

    function exportGPX(){ if(!trackPoints.length){ alert('No track to export'); return; } const name = 'BHH Track ' + new Date(trackPoints[0].t).toISOString().slice(0,10); const head = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<gpx version=\"1.1\" creator=\"BuckeyeHunterHub\" xmlns=\"http://www.topografix.com/GPX/1/1\">\n<trk><name>${name}</name><trkseg>`; const seg = trackPoints.map(p=>`<trkpt lat=\"${p.lat}\" lon=\"${p.lng}\"><time>${new Date(p.t).toISOString()}</time></trkpt>`).join(''); const tail = `</trkseg></trk></gpx>`; const blob = new Blob([head+seg+tail], {type:'application/gpx+xml'}); const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=name.replace(/\s+/g,'_')+'.gpx'; a.click(); URL.revokeObjectURL(url); }

    loadTrack();

    /*******************
     * WIND (live) + SCENT CONE
     *******************/
    const btnWind = document.getElementById('menuWind');
    const windText = document.getElementById('windText');
    const windArrow = document.getElementById('windArrow');

    let currentWind = { fromDeg: null, speed: 0 };
    let lastGPS = null;

    function degToCardinal(d){ const dirs = ['N','NE','E','SE','S','SW','W','NW']; return dirs[Math.round(d/45)%8]; }
    function updateWindUI(fromDeg, speed){ const toDeg = (fromDeg + 180) % 360; const from = degToCardinal(fromDeg); const to = degToCardinal(toDeg); windArrow.style.transform = `rotate(${toDeg}deg)`; windText.textContent = `Wind: ${from} → ${to}  ${Math.round(speed)} mph`; }

    async function fetchWindAt(lat, lng){ const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&current=wind_speed_10m,wind_direction_10m&wind_speed_unit=mph`; const r = await fetch(url); if(!r.ok) throw new Error('wind fetch failed'); const j = await r.json(); const cur = j.current || j.current_weather || {}; const speed = cur.wind_speed_10m ?? cur.windspeed ?? 0; const dir = cur.wind_direction_10m ?? cur.winddirection ?? 0; currentWind = { fromDeg: dir, speed }; updateWindUI(dir, speed); updateScentCone(); }

    async function refreshWind(){
      try{
        const pos = await new Promise((res,rej)=>{ if(!navigator.geolocation) return rej('no geo'); navigator.geolocation.getCurrentPosition(p=>res(p), e=>rej(e), {enableHighAccuracy:true, timeout:6000}); });
        lastGPS = { lat: pos.coords.latitude, lng: pos.coords.longitude };
        await fetchWindAt(lastGPS.lat, lastGPS.lng);
      } catch(_) {
        const c = map.getCenter();
        await fetchWindAt(c.lat, c.lng).catch(()=>{ windText.textContent='Wind: n/a'; });
      }
    }

    // Wind sheet controls
    const windRefreshBtn = document.getElementById('windRefresh');
    const coneToggle = document.getElementById('coneToggle');
    const coneWidth = document.getElementById('coneWidth');
    const coneScale = document.getElementById('coneScale');
    const coneAnchorRadios = Array.from(document.querySelectorAll('input[name="coneAnchor"]'));

    // Restore settings
    (function restoreConeSettings(){
      coneToggle.checked = localStorage.getItem('cone_vis')==='1';
      coneWidth.value = localStorage.getItem('cone_w') || '60';
      coneScale.value = localStorage.getItem('cone_s') || '1';
      const anch = localStorage.getItem('cone_a') || 'gps';
      const r = coneAnchorRadios.find(x=>x.value===anch); if(r) r.checked=true;
    })();

    let scentConeLayer = L.polygon([], { color:'#f59e0b', weight:2, fillColor:'#f59e0b', fillOpacity:0.2 });

    function toRad(x){ return x*Math.PI/180; }
    function toDeg(x){ return x*180/Math.PI; }
    function destPoint(lat,lng,bearingDeg,distM){
      const R=6378137; const br=toRad(bearingDeg); const lat1=toRad(lat), lon1=toRad(lng); const dr=distM/R;
      const lat2 = Math.asin(Math.sin(lat1)*Math.cos(dr) + Math.cos(lat1)*Math.sin(dr)*Math.cos(br));
      const lon2 = lon1 + Math.atan2(Math.sin(br)*Math.sin(dr)*Math.cos(lat1), Math.cos(dr)-Math.sin(lat1)*Math.sin(lat2));
      return L.latLng(toDeg(lat2), toDeg(lon2));
    }

    function updateScentCone(){
      if(!coneToggle.checked){ if(map.hasLayer(scentConeLayer)) map.removeLayer(scentConeLayer); return; }
      const wind = currentWind; if(wind.fromDeg==null){ return; }
      const toDegWind = (wind.fromDeg + 180) % 360;
      const width = parseFloat(coneWidth.value); const half = width/2;
      const scale = parseFloat(coneScale.value);
      const speed = Math.max(1, wind.speed||1); // mph
      const baseLen = 150 + speed*90; // meters, empirical
      const length = baseLen * scale;
      const anchorMode = (coneAnchorRadios.find(r=>r.checked)?.value) || 'gps';
      const origin = (anchorMode==='gps' && lastGPS) ? lastGPS : map.getCenter();

      // Build sector polygon
      const pts = [L.latLng(origin.lat, origin.lng)];
      for(let a=-half; a<=half; a+= Math.max(5, width/8)){
        pts.push(destPoint(origin.lat, origin.lng, toDegWind+a, length));
      }
      pts.push(L.latLng(origin.lat, origin.lng));
      scentConeLayer.setLatLngs([pts]);
      if(!map.hasLayer(scentConeLayer)) scentConeLayer.addTo(map);
    }

    // Persist changes
    function persistCone(){ localStorage.setItem('cone_vis', coneToggle.checked?'1':'0'); localStorage.setItem('cone_w', coneWidth.value); localStorage.setItem('cone_s', coneScale.value); const anch = (coneAnchorRadios.find(r=>r.checked)||{}).value||'gps'; localStorage.setItem('cone_a', anch); }
    coneToggle.onchange = ()=>{ persistCone(); updateScentCone(); };
    coneWidth.oninput = ()=>{ persistCone(); updateScentCone(); };
    coneScale.oninput = ()=>{ persistCone(); updateScentCone(); };
    coneAnchorRadios.forEach(r=> r.addEventListener('change', ()=>{ persistCone(); updateScentCone(); }));

    // Wind button: open sheet + refresh
    const btnMoon = document.getElementById('menuMoon');
    const btnScore = document.getElementById('menuScore');
    btnWind.onclick = ()=>{ openSheet('wind'); refreshWind(); };
    windRefreshBtn.onclick = ()=> refreshWind();

    // Keep scent cone current
    map.on('moveend', ()=>{ const anch = localStorage.getItem('cone_a')||'gps'; if(anch==='center') updateScentCone(); });

    // Initial wind fetch + periodic
    refreshWind(); setInterval(refreshWind, 15*60*1000);

    /*******************
     * OHIO PUBLIC HUNTING (Local file first, then ODNR)
     *******************/
    const ohioPublic = L.geoJSON(null, {
      style:{ color:'#8b5cf6', weight:2, fillOpacity:0.15 },
      onEachFeature:(feat, layer)=>{
        const p = feat && feat.properties ? feat.properties : {};
        const preferred = ['NAME','AREA_NAME','UNIT_NAME','PARK_NAME','SITE_NAME','COUNTY','ACRES','AREA_ACRES','OWNER','AGENCY','STATUS','TYPE','ACCESS','SEASON'];
        const headerKey = preferred.find(k=> k in p) || Object.keys(p)[0];
        const name = headerKey ? String(p[headerKey]) : 'Public Hunting Area';
        const keysOrdered = [...new Set([...preferred.filter(k=>k in p), ...Object.keys(p)])].slice(0,12);
        const rows = keysOrdered.map(k=>`<div><span style=\"color:#a3b7a6\">${k}:</span> ${String(p[k])}</div>`).join('');
        layer.bindPopup(`<b>${name}</b><div style=\"margin-top:6px\">${rows}</div>`);
        layer.on('mouseover', ()=> layer.setStyle({weight:3}));
        layer.on('mouseout',  ()=> layer.setStyle({weight:2}));
      }
    });

    async function loadOhioPublic(){
      try{ const localResp = await fetch('ohio_public_hunting.geojson', {cache:'reload'}); if(localResp.ok){ const localJson = await localResp.json(); ohioPublic.addData(localJson); console.info('Loaded local ohio_public_hunting.geojson'); return; } }catch(e){ console.info('Local ohio_public_hunting.geojson not found'); }
      try{ const odnrResp = await fetch('https://gis2.ohiodnr.gov/ArcGIS/rest/services/OIT_Services/DNR_Fed_Lands_Nav_Base/MapServer/2/query?where=1%3D1&outFields=*&outSR=4326&f=geojson'); const odnrJson = await odnrResp.json(); ohioPublic.addData(odnrJson); console.info('Loaded ODNR fallback layer'); }catch(err){ console.warn('ODNR layer fetch failed', err); }
    }
    loadOhioPublic();

    /*******************
     * OHIO COUNTIES (outline + always-on labels)
     *******************/
    const ohioCounties = L.geoJSON(null, {
      style: { color:'#94a3b8', weight:1, fill:false, opacity:0.9 },
      onEachFeature: (feat, layer) => {
        const name = (feat.properties && (feat.properties.County_Name || feat.properties.COUNTY_NAME)) || 'County';
        // Keep hover thickness
        layer.on('mouseover', ()=> layer.setStyle({ weight:2 }));
        layer.on('mouseout',  ()=> layer.setStyle({ weight:1 }));
        // Store name for labeling
        layer._countyName = String(name);
      }
    });

    const countyLabels = L.layerGroup();

    function labelFontForZoom(z){ if(z>=11) return 14; if(z>=9) return 12; if(z>=7) return 10; return 0; }
    function refreshCountyLabels(){
      const fs = labelFontForZoom(map.getZoom());
      countyLabels.eachLayer(m => {
        const el = m.getElement();
        if(!el) return;
        if(fs===0){ el.style.display='none'; }
        else { el.style.display='block'; el.style.fontSize = fs+'px'; }
      });
    }

    function buildCountyLabels(){
      countyLabels.clearLayers();
      ohioCounties.eachLayer(layer => {
        try{
          const center = layer.getBounds().getCenter();
          const name = layer._countyName || 'County';
          const lbl = L.marker(center, {
            interactive:false,
            pane:'tooltipPane',
            icon: L.divIcon({ className:'county-label', html: name })
          });
          countyLabels.addLayer(lbl);
        }catch(_){/* ignore */}
      });
      refreshCountyLabels();
      if(map.hasLayer(ohioCounties) && !map.hasLayer(countyLabels)) countyLabels.addTo(map);
    }

    async function loadOhioCounties(){
      try{
        const url = 'https://gis.dot.state.oh.us/arcgis/rest/services/Basemap/ODOT_Basemap/MapServer/165/query?where=1%3D1&outFields=County_Name&outSR=4326&f=geojson';
        const r = await fetch(url);
        const j = await r.json();
        ohioCounties.addData(j);
        buildCountyLabels();
      }catch(e){ console.warn('Counties layer fetch failed', e); }
    }
    loadOhioCounties();
    map.on('zoomend', refreshCountyLabels);

    /*******************
     * RADAR LAYERS     *
     *******************/
    const radarRain = L.tileLayer('https://tilecache.rainviewer.com/v2/radar/nowcast/256/{z}/{x}/{y}/2/1_1.png', { opacity: 0.6, attribution: 'RainViewer' });
    const radarNoaa = L.tileLayer.wms('https://opengeo.ncep.noaa.gov/geoserver/conus/conus_bref_qcd/ows?', { layers: 'conus_bref_qcd', format: 'image/png', transparent: true, opacity: 0.6, attribution: 'NOAA/NWS' });

    function setRadarSource(src){ const vis = document.getElementById('radarToggle').checked; map.removeLayer(radarRain); map.removeLayer(radarNoaa); if(!vis) return; if(src==='noaa') { radarNoaa.setOpacity(parseFloat(radarOpacity.value)); radarNoaa.addTo(map); } else { radarRain.setOpacity(parseFloat(radarOpacity.value)); radarRain.addTo(map); } localStorage.setItem('radar_src', src); }
    function setRadarVisibility(v){ document.getElementById('radarToggle').checked = v; localStorage.setItem('radar_vis', v? '1':'0'); setRadarSource(localStorage.getItem('radar_src')||'rainviewer'); }
    function setRadarOpacity(val){ const v=parseFloat(val); radarRain.setOpacity(v); radarNoaa.setOpacity(v); localStorage.setItem('radar_opacity', v.toString()); }

    /*******************
     * LAYERS CONTROL   *
     *******************/
    const overlaysForControl = { 'Ohio Public Hunting': ohioPublic, 'Ohio Counties': ohioCounties, 'Hunt Markers': markersLayer, 'My Drawings': drawnItems, 'My Track': trackLayer };
    L.control.layers({ 'Basic':basic, 'Satellite':satellite, 'Topographic':topo }, overlaysForControl, { position:'bottomleft' }).addTo(map);

    /*******************
     * BOTTOM MENU ACTIONS
     *******************/
    const btnBasemap = document.getElementById('toggleBasemap');
    const btnLocate  = document.getElementById('menuLocate');
    const btnWaypoints = document.getElementById('menuWaypoints');
    const btnTrack = document.getElementById('menuTrack');
    const btnRadar = document.getElementById('menuRadar');
    const btnExport = document.getElementById('btnExport');
    const btnImport = document.getElementById('btnImport');
    const btnDelete = document.getElementById('btnDeleteMode');
    const fileInput = document.getElementById('fileImport');

    const sheetBg = document.getElementById('sheetBackdrop');
    const sheetMap = { basemap: document.getElementById('basemapSheet'), waypoints: document.getElementById('waypointsSheet'), track: document.getElementById('trackSheet'), radar: document.getElementById('radarSheet'), wind: document.getElementById('windSheet'), moon: document.getElementById('moonSheet'), score: document.getElementById('scoreSheet') };
    function openSheet(which){ Object.values(sheetMap).forEach(s=> s.classList.remove('show')); sheetBg.classList.add('show'); sheetMap[which].classList.add('show'); if(which==='waypoints') refreshWaypointsUI(); if(which==='basemap'){ syncOverlayChecks(); syncBaseRadio(); } if(which==='moon'){ renderMoon(); } if(which==='score'){ computeHuntScore(); } }
    function closeSheets(){ sheetBg.classList.remove('show'); Object.values(sheetMap).forEach(s=> s.classList.remove('show')); }
    sheetBg.onclick = closeSheets;

    // Make entire .option row clickable (toggle inner input)
    document.querySelectorAll('.sheet .option').forEach(opt=>{
      opt.addEventListener('click', ()=>{
        const input = opt.querySelector('input'); if(!input) return;
        if(input.type==='radio'){ input.checked = true; input.dispatchEvent(new Event('change', {bubbles:true})); }
        if(input.type==='checkbox'){ input.checked = !input.checked; input.dispatchEvent(new Event('change', {bubbles:true})); }
      });
    });

    // Basemap sheet wiring
    const radios = Array.from(document.querySelectorAll('input[name="basemap"]'));
    function syncBaseRadio(){ const k = localStorage.getItem(STORAGE_BASE) || 'basic'; const r = radios.find(r=>r.value===k); if(r) r.checked = true; }
    btnBasemap.onclick = ()=>{ openSheet('basemap'); };
    radios.forEach(r=> r.addEventListener('change', ()=>{ setBasemap(r.value); }));

    // Overlay toggles in the basemap sheet
    const ovlOhio = document.getElementById('ovlOhio');
    const ovlCounties = document.getElementById('ovlCounties');
    const ovlDraw = document.getElementById('ovlDraw');
    const ovlMarks = document.getElementById('ovlMarks');
    const ovlTrack = document.getElementById('ovlTrack');

    function syncOverlayChecks(){
      ovlOhio.checked = map.hasLayer(ohioPublic);
      ovlCounties.checked = map.hasLayer(ohioCounties);
      ovlDraw.checked = map.hasLayer(drawnItems);
      ovlMarks.checked = map.hasLayer(markersLayer);
      ovlTrack.checked = map.hasLayer(trackLayer);
    }

    ovlOhio.onchange = ()=> ovlOhio.checked ? ohioPublic.addTo(map) : map.removeLayer(ohioPublic);
    ovlCounties.onchange = ()=> {
      if(ovlCounties.checked){
        ohioCounties.addTo(map);
        countyLabels.addTo(map);
        refreshCountyLabels();
      } else {
        map.removeLayer(ohioCounties);
        map.removeLayer(countyLabels);
      }
    };
    ovlDraw.onchange = ()=> ovlDraw.checked ? drawnItems.addTo(map) : map.removeLayer(drawnItems);
    ovlMarks.onchange = ()=> ovlMarks.checked ? markersLayer.addTo(map) : map.removeLayer(markersLayer);
    ovlTrack.onchange = ()=> ovlTrack.checked ? trackLayer.addTo(map) : map.removeLayer(trackLayer);

    // Keep labels in sync when toggled via the Layers control
    map.on('overlayadd', (e)=>{ if(e.layer===ohioCounties){ countyLabels.addTo(map); refreshCountyLabels(); } });
    map.on('overlayremove', (e)=>{ if(e.layer===ohioCounties){ map.removeLayer(countyLabels); } });

    // Sheets buttons
    document.getElementById('toggleFieldInfo').onclick = ()=> setInfoVisible(infoPanel.style.display==='none' || infoPanel.style.display==='');
    btnMoon.onclick = ()=> openSheet('moon');
    btnScore.onclick = ()=> openSheet('score');
    btnWaypoints.onclick = ()=> openSheet('waypoints');
    btnTrack.onclick = ()=> openSheet('track');

    // Radar button toggles visibility quickly, then opens sheet
    const radarToggle = document.getElementById('radarToggle');
    const radarOpacity = document.getElementById('radarOpacity');
    const radarSrcRadios = Array.from(document.querySelectorAll('input[name="radarSrc"]'));
    function restoreRadar(){ const vis = localStorage.getItem('radar_vis')==='1'; const src = localStorage.getItem('radar_src')||'rainviewer'; const op = parseFloat(localStorage.getItem('radar_opacity')||'0.6'); radarToggle.checked = vis; radarOpacity.value = op; const r = radarSrcRadios.find(r=>r.value===src); if(r) r.checked=true; setRadarOpacity(op); setRadarSource(src); }
    btnRadar.onclick = ()=>{ const wasVis = localStorage.getItem('radar_vis')==='1'; setRadarVisibility(!wasVis); restoreRadar(); openSheet('radar'); };
    radarToggle.onchange = ()=> setRadarVisibility(radarToggle.checked);
    radarOpacity.oninput = ()=> setRadarOpacity(radarOpacity.value);
    radarSrcRadios.forEach(r=> r.addEventListener('change', ()=> setRadarSource(r.value)));

    // Field Info toggle & position persistence
    const infoPanel = document.getElementById('infoPanel');
    const btnFieldInfo = document.getElementById('toggleFieldInfo');
    const STORAGE_INFO_POS = 'ui_info_pos';
    const STORAGE_INFO_VIS = 'ui_info_visible';
    function setInfoVisible(v){ infoPanel.style.display = v? 'block':'none'; localStorage.setItem(STORAGE_INFO_VIS, v? '1':'0'); if(v){ updateSun(); updateTrackStats(); } }
    function getInfoVisible(){ return localStorage.getItem(STORAGE_INFO_VIS) === '1'; }
    setInfoVisible(getInfoVisible());

    // Export / Import / Delete mode (bottom menu)
    btnExport.onclick = () => { const drawings = JSON.parse(localStorage.getItem(STORAGE_DRAW) || '{}'); const data = { drawings, markers: serializeMarkers(), track: trackPoints }; const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href=url; a.download='buckeyehunterhub-export.json'; a.click(); URL.revokeObjectURL(url); };
    btnImport.onclick = () => fileInput.click();
    fileInput.onchange = (ev) => { const f = ev.target.files[0]; if(!f) return; const r=new FileReader(); r.onload = () => { try{ const obj = JSON.parse(r.result);
        if(obj.drawings && (obj.drawings.geojson || obj.drawings.circles)){
          localStorage.setItem(STORAGE_DRAW, JSON.stringify(obj.drawings));
          drawnItems.clearLayers(); segmentLabelsGroup.clearLayers(); restoreDraw();
        } else if(obj.type==='FeatureCollection' || obj.type==='Feature'){
          L.geoJSON(obj, {onEachFeature:(_,l)=> drawnItems.addLayer(l)});
          saveDraw();
        }
        if(obj.markers) deserializeMarkers(obj.markers);
        if(obj.track) { trackPoints = obj.track; trackLayer.setLatLngs(trackPoints.map(p=>[p.lat,p.lng])); saveTrack(); }
      } catch{ alert('Invalid JSON/GeoJSON file'); } finally { ev.target.value=''; } }; r.readAsText(f); };
    btnDelete.onclick = () => { deleteMode = !deleteMode; btnDelete.textContent = `Delete: ${deleteMode? 'On':'Off'}`; };

    // Locate
    btnLocate.onclick = ()=>{ if(!navigator.geolocation){ alert('Geolocation not supported'); return; } navigator.geolocation.getCurrentPosition(pos=>{ const latlng=[pos.coords.latitude, pos.coords.longitude]; map.setView(latlng, 15); }, err=> alert('Location error: '+err.message), { enableHighAccuracy:true, timeout:8000 }); };

    // Draggable Field Info
    function makeDraggable(el, handle, storageKey){
      let sx=0, sy=0, sl=0, st=0, dragging=false;
      function point(e){ if(e.touches && e.touches[0]) return {x:e.touches[0].clientX,y:e.touches[0].clientY}; return {x:e.clientX,y:e.clientY}; }
      function apply(l,t){ const vw=innerWidth, vh=innerHeight; const w=el.offsetWidth, h=el.offsetHeight; l=Math.max(4,Math.min(vw-w-4,l)); t=Math.max(60,Math.min(vh-h-4,t)); el.style.left=l+'px'; el.style.top=t+'px'; }
      function savePos(){ const r=el.getBoundingClientRect(); localStorage.setItem(storageKey, JSON.stringify({left:r.left, top:r.top})); }
      function move(e){ if(!dragging) return; const p=point(e); apply(sl+p.x-sx, st+p.y-sy); e.preventDefault(); }
      function tmove(e){ if(!dragging) return; const p=point(e); apply(sl+p.x-sx, st+p.y-sy); e.preventDefault(); }
      function up(){ dragging=false; document.removeEventListener('mousemove',move); document.removeEventListener('mouseup',up); document.removeEventListener('touchmove',tmove); document.removeEventListener('touchend',up); savePos(); }
      function start(x,y){ dragging=true; sx=x; sy=y; const r=el.getBoundingClientRect(); sl=r.left; st=r.top; document.addEventListener('mousemove',move); document.addEventListener('mouseup',up); document.addEventListener('touchmove',tmove,{passive:false}); document.addEventListener('touchend',up); }
      function down(e){ const p=point(e); start(p.x,p.y); e.preventDefault(); }
      function tdown(e){ const p=point(e); start(p.x,p.y); }
      try{ const s=JSON.parse(localStorage.getItem(storageKey)||'null'); if(s){ el.style.left=s.left+'px'; el.style.top=s.top+'px'; } }catch{}
      handle.addEventListener('mousedown',down);
      handle.addEventListener('touchstart',tdown,{passive:false});
    }
    makeDraggable(document.getElementById('infoPanel'), document.getElementById('infoHandle'), 'ui_info_pos');

    /*******************
     * SUN & MOON       *
     *******************/
    function updateSun(){ const c = map.getCenter(); const now = new Date(); const t = SunCalc.getTimes(now, c.lat, c.lng); const fmt = d => d ? d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}) : '--:--'; document.getElementById('pSunrise').textContent = fmt(t.sunrise); document.getElementById('pSunset').textContent  = fmt(t.sunset); const mins = Math.max(0, (t.sunset - t.sunrise)/60000|0); document.getElementById('pDay').textContent = `${Math.floor(mins/60)}h ${mins%60}m`; }
    updateSun(); map.on('moveend', updateSun);

    function phaseName(phase){
      // SunCalc phase: 0 new → 0.25 first quarter → 0.5 full → 0.75 last quarter → 1 new
      const p = (phase + 1) % 1;
      if(p < 0.03 || p > 0.97) return 'New Moon';
      if(p < 0.22) return 'Waxing Crescent';
      if(p < 0.28) return 'First Quarter';
      if(p < 0.47) return 'Waxing Gibbous';
      if(p < 0.53) return 'Full Moon';
      if(p < 0.72) return 'Waning Gibbous';
      if(p < 0.78) return 'Last Quarter';
      return 'Waning Crescent';
    }
    function phaseEmoji(phase){
      const p=(phase+1)%1;
      if(p < 0.03 || p > 0.97) return '🌑';
      if(p < 0.22) return '🌒';
      if(p < 0.28) return '🌓';
      if(p < 0.47) return '🌔';
      if(p < 0.53) return '🌕';
      if(p < 0.72) return '🌖';
      if(p < 0.78) return '🌗';
      return '🌘';
    }

    function renderMoon(){
      const c = map.getCenter();
      const now = new Date();
      const illum = SunCalc.getMoonIllumination(now);
      const mt = SunCalc.getMoonTimes(now, c.lat, c.lng, true);
      const fmt = d => d ? d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}) : '--:--';
      const pct = Math.round(illum.fraction*100);
      let html = `<div class="row"><span>Today</span><strong class="tag">${phaseEmoji(illum.phase)} ${phaseName(illum.phase)} · ${pct}%</strong></div>`+
                 `<div class="row"><span>Moonrise</span><strong class="tag">${fmt(mt.rise)}</strong></div>`+
                 `<div class="row"><span>Moonset</span><strong class="tag">${fmt(mt.set)}</strong></div>`+
                 `<p class="tag" style="margin-top:6px">Next 7 days</p>`;
      for(let i=1;i<=7;i++){
        const d = new Date(now.getFullYear(), now.getMonth(), now.getDate()+i);
        const im = SunCalc.getMoonIllumination(d);
        const tt = SunCalc.getMoonTimes(d, c.lat, c.lng, true);
        html += `<div class="row"><span>${d.toLocaleDateString([], {weekday:'short', month:'short', day:'numeric'})}</span><strong class="tag">${phaseEmoji(im.phase)} ${Math.round(im.fraction*100)}% · ${fmt(tt.rise)} / ${fmt(tt.set)}</strong></div>`;
      }
      document.getElementById('moonContent').innerHTML = html;
    }

    /*******************
     * HUNT SCORE       *
     *******************/
    const scoreList = document.getElementById('scoreList');
    const scoreRefreshBtn = document.getElementById('scoreRefresh');
    const scoreLocRadios = Array.from(document.querySelectorAll('input[name="scoreLoc"]'));

    function gauss(x, mu, sigma){ const z=(x-mu)/sigma; return Math.exp(-0.5*z*z); }
    function clamp(v,min,max){ return Math.min(max, Math.max(min,v)); }

    async function fetchForecast(lat,lng){
      const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&hourly=temperature_2m,wind_speed_10m,precipitation_probability,cloud_cover,surface_pressure&daily=sunrise,sunset&forecast_days=3&timezone=auto&wind_speed_unit=mph`;
      const r = await fetch(url); if(!r.ok) throw new Error('forecast fetch failed'); return r.json();
    }

    function buildSunWindows(daily){
      const windows = {}; // dateStr -> {sr, ss}
      for(let i=0;i<daily.time.length;i++){
        windows[daily.time[i]] = { sr: new Date(daily.sunrise[i]), ss: new Date(daily.sunset[i]) };
      }
      return windows;
    }

    function lunarBoost(date, lat, lng){
      // small bonus if moon is low during predawn/dusk on new-ish moon, or overhead mid-day on full-ish moon
      const ill = SunCalc.getMoonIllumination(date);
      const pos = SunCalc.getMoonPosition(date, lat, lng);
      const frac = ill.fraction; // 0..1
      const alt = pos.altitude;  // radians
      let boost = 0;
      if(frac < 0.3){ // near new — better at dawn/dusk when moon is low
        boost += clamp((0.3 - frac)/0.3, 0, 1) * clamp((0.2 - Math.abs(alt))/0.2, 0, 1) * 12;
      } else if(frac > 0.7){ // near full — mid-day overhead can see a small bump
        boost += clamp((frac - 0.7)/0.3, 0, 1) * clamp((alt - 0.4)/0.6, 0, 1) * 8;
      }
      return boost; // up to ~12
    }

    async function computeHuntScore(){
      scoreList.innerHTML = '<p class="tag">Loading forecast…</p>';
      let anchor = map.getCenter();
      const which = (scoreLocRadios.find(r=>r.checked)||{}).value || 'gps';
      if(which==='gps'){
        try{ const pos = await new Promise((res,rej)=>{ if(!navigator.geolocation) return rej('no geo'); navigator.geolocation.getCurrentPosition(p=>res(p), e=>rej(e), {enableHighAccuracy:true, timeout:6000}); }); anchor = { lat: pos.coords.latitude, lng: pos.coords.longitude }; } catch(e){}
      }
      let data; try{ data = await fetchForecast(anchor.lat, anchor.lng); } catch(e){ scoreList.innerHTML = '<p class="tag">Forecast unavailable.</p>'; return; }
      const hourly = data.hourly || {}; const times = (hourly.time||[]).map(t=> new Date(t));
      const ws = hourly.wind_speed_10m || []; const tp = hourly.temperature_2m || []; const pr = hourly.precipitation_probability || []; const cc = hourly.cloud_cover || []; const sp = hourly.surface_pressure || [];
      const sun = buildSunWindows(data.daily || {time:[], sunrise:[], sunset:[]});

      // compute day medians for temperature baseline by date
      const byDay = {};
      times.forEach((d,i)=>{ const k=d.toISOString().slice(0,10); (byDay[k]||(byDay[k]={temps:[]})).temps.push(tp[i]); });
      const medByDay = {}; Object.keys(byDay).forEach(k=>{ const arr = byDay[k].temps.slice().sort((a,b)=>a-b); const m = arr[Math.floor(arr.length/2)]||arr[0]||0; medByDay[k]=m; });

      const rows = [];
      for(let i=0;i<times.length;i++){
        const d = times[i]; const dateKey=d.toISOString().slice(0,10);
        // Light factor: peaks at sunrise/sunset (±90 min)
        const dayWin = sun[dateKey];
        let light = 0.2; // base
        if(dayWin){
          const minsFrom = (a)=> Math.abs((d - a)/60000);
          light = Math.max( gauss(minsFrom(dayWin.sr), 0, 65), gauss(minsFrom(dayWin.ss), 0, 65) );
        }
        light = clamp(light, 0, 1);

        // Wind factor: prefer 4–12 mph; too calm or >20 mph penalize
        const w = ws[i] ?? 0; const wind = Math.max( gauss(w, 8, 4), gauss(w, 10, 5) );

        // Temp factor: better when cooler than the day's median
        const t = tp[i] ?? 0; const med = medByDay[dateKey] ?? t; const temp = clamp( (med - t) / 12, -0.5, 1 ); // ~+1 when 12°F cooler

        // Precip penalty if high probability
        const p = pr[i] ?? 0; const precip = 1 - clamp((p-30)/70, 0, 1); // <30% fine; 100% → strong penalty

        // Cloud cover slight positive near full moon at dawn; slight negative at day otherwise (keep tiny)
        const cloud = 1 - (cc[i]||0)/300; // very small weight

        // Lunar small boost
        const lunar = lunarBoost(d, anchor.lat, anchor.lng) / 12; // normalize 0..1

        // Combine with weights → 0..100
        const score = clamp(
          (light*0.38 + wind*0.22 + (temp+0.5)*0.16 + precip*0.18 + cloud*0.02 + lunar*0.04) * 100,
          0, 100
        );
        rows.push({ d, score: Math.round(score), wind:w, temp:t, precip: p });
      }

      // Keep next 48h
      const now = new Date();
      const next48 = rows.filter(r=> r.d - now >= 0 && r.d - now <= 48*3600*1000);
      next48.sort((a,b)=> b.score - a.score);
      const top = next48.slice(0, 16).sort((a,b)=> a.d - b.d); // show 16 best, chronological

      scoreList.innerHTML = top.map(r=>{
        const w = r.score; const bar = Math.round(w);
        const time = r.d.toLocaleString([], {weekday:'short', month:'short', day:'numeric', hour:'2-digit'});
        return `<div class="score-item">
          <div class="tag">${time}</div>
          <div class="bar"><span style="width:${bar}%"></span></div>
          <div class="tag" style="text-align:right">${w} / 100</div>
        </div>`;
      }).join('') || '<p class="tag">No forecast rows.</p>';
    }
    scoreRefreshBtn.onclick = ()=> computeHuntScore();

  </script>
</body>
</html>
